<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>银河之家</title>
  
  
  <link href="https://yingyingmonstre.github.io/atom.xml" rel="self"/>
  
  <link href="https://yingyingmonstre.github.io/"/>
  <updated>2021-09-17T07:59:53.400Z</updated>
  <id>https://yingyingmonstre.github.io/</id>
  
  <author>
    <name>银河</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ModbusTCP协议学习</title>
    <link href="https://yingyingmonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://yingyingmonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-17T07:12:00.000Z</published>
    <updated>2021-09-17T07:59:53.400Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/ioufev/articles/10830028.html">ModbusTCP协议 - ioufev - 博客园 (cnblogs.com)</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Modbus由MODICON公司于1979年开发，是一种<strong>工业现场总线</strong>协议标准。1996年<strong>施耐德</strong>公司推出基于<strong>以太网TCP/IP</strong>的Modbus协议：<strong>Modbus TCP</strong>。</p><p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、<strong>TCP</strong>三种报文类型。</p><p>标准的Modbus协议物理层接口有RS232、RS422、RS485和<strong>以太网</strong>接口，采用<strong>master/slave</strong>方式通信。</p><h2 id="Modbus-TCP数据帧"><a href="#Modbus-TCP数据帧" class="headerlink" title="Modbus TCP数据帧"></a>Modbus TCP数据帧</h2><p>ModbusTCP的数据帧可分为两部分：<strong>MBAP</strong>+<strong>PDU</strong>。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.51wendang.com%2Fpic%2Fe5675f007044fd1446490edf%2F2-537-png_6_0_0_464_608_341_194_892.8_1262.699-947-0-526-947.jpg&refer=http%3A%2F%2Fwww.51wendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634438115&t=92f4357504d2885188a29589d7de4e7f"></p><center>图1 Modbus TCP协议特征</center><h3 id="报文头MBAP"><a href="#报文头MBAP" class="headerlink" title="报文头MBAP"></a>报文头MBAP</h3><p>MBAP为报文头，长度为7字节，组成如下：</p><table><thead><tr><th>事务处理标识</th><th>协议标识</th><th>长度</th><th>单元标识符</th></tr></thead><tbody><tr><td>2字节</td><td>2字节</td><td>2字节</td><td>1字节</td></tr></tbody></table><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td><strong>事务处理标识</strong></td><td>可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文。</td></tr><tr><td><strong>协议标识符</strong></td><td>00 00表示Modbus TCP协议。</td></tr><tr><td><strong>长度</strong></td><td>表示接下来的数据长度，单位为字节。</td></tr><tr><td><strong>单元标识符</strong></td><td>可以理解为设备地址。</td></tr></tbody></table><h3 id="帧结构PDU"><a href="#帧结构PDU" class="headerlink" title="帧结构PDU"></a>帧结构PDU</h3><p>PDU由<strong>功能码+数据</strong>组成。功能码为1字节，数据长度不定，由具体功能决定。</p><p><strong>功能码</strong></p><p>Modbus的操作对象有四种：线圈、离散输入、保持寄存器、输入寄存器。</p><table><thead><tr><th>对象</th><th>含义</th></tr></thead><tbody><tr><td>线圈</td><td>PLC的输出位，开关量，在Modbus中可读可写</td></tr><tr><td>离散量</td><td>PLC的输入位，开关量，在Modbus中只读</td></tr><tr><td>输入寄存器</td><td>PLC中只能从模拟量输入端改变的寄存器，在Modbus中只读</td></tr><tr><td>保持寄存器</td><td>PLC中用于输出模拟量信号的寄存器，在Modbus中可读可写</td></tr></tbody></table><p>根据对象的不同，Modbus的功能码有：</p><table><thead><tr><th>功能码</th><th>含义</th></tr></thead><tbody><tr><td>0x01</td><td>读线圈</td></tr><tr><td>0x05</td><td>写单个线圈</td></tr><tr><td>0x0F</td><td>写多个线圈</td></tr><tr><td>0x02</td><td>读离散量输入</td></tr><tr><td>0x04</td><td>读输入寄存器</td></tr><tr><td>0x03</td><td>读保持寄存器</td></tr><tr><td>0x06</td><td>写单个保持寄存器</td></tr><tr><td>0x10</td><td>写多个保持寄存器</td></tr></tbody></table><p>说明更详细的表</p><table><thead><tr><th>代码</th><th>中文名称</th><th>英文名</th><th>位操作/字操作</th><th>操作数量</th></tr></thead><tbody><tr><td>01</td><td>读线圈状态</td><td>READ COIL STATUS</td><td>位操作</td><td>单个或多个</td></tr><tr><td>02</td><td>读离散输入状态</td><td>READ INPUT STATUS</td><td>位操作</td><td>单个或多个</td></tr><tr><td>03</td><td>读保持寄存器</td><td>READ HOLDING REGISTER</td><td>字操作</td><td>单个或多个</td></tr><tr><td>04</td><td>读输入寄存器</td><td>READ INPUT REGISTER</td><td>字操作</td><td>单个或多个</td></tr><tr><td>05</td><td>写线圈状态</td><td>WRITE SINGLE COIL</td><td>位操作</td><td>单个</td></tr><tr><td>06</td><td>写单个保持寄存器</td><td>WRITE SINGLE REGISTER</td><td>字操作</td><td>单个</td></tr><tr><td>15</td><td>写多个线圈</td><td>WRITE MULTIPLE COIL</td><td>位操作</td><td>多个</td></tr><tr><td>16</td><td>写多个保持寄存器</td><td>WRITE MULTIPLE REGISTER</td><td>字操作</td><td>多个</td></tr></tbody></table><h2 id="PDU详细结构"><a href="#PDU详细结构" class="headerlink" title="PDU详细结构"></a>PDU详细结构</h2><p>测试软件：mod_RSsim5.3</p><table><thead><tr><th>模式</th><th>对应</th></tr></thead><tbody><tr><td>线圈</td><td>Coil Outputs</td></tr><tr><td>离散量</td><td>Digital Inputs</td></tr><tr><td>输入寄存器</td><td>Analogue Inputs</td></tr><tr><td>保持寄存器</td><td>Holding Registers</td></tr></tbody></table><p><strong>0x01：读线圈</strong></p><p>在从站中读1~2000个连续线圈状态，ON=1,OFF=0</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 数据（一个地址的数据为1位）</li><li>如：在从站0x01中，读取开始地址为0x0002的线圈数据，读0x0008位<br>00 01 00 00 00 06 01 01 00 02 00 08</li><li>回：数据长度为0x01个字节，数据为0x01，第一个线圈为ON，其余为OFF<br>00 01 00 00 00 04 01 01 01 01</li></ul><p><strong>0x05：写单个线圈</strong></p><p>将从站中的一个输出写成ON或OFF，0xFF00请求输出为ON,0x000请求输出为OFF</p><ul><li>请求：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</li><li>响应：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</li><li>如：将地址为0x0003的线圈设为ON<br>00 01 00 00 00 06 01 05 00 03 FF 00</li><li>回：写入成功<br>00 01 00 00 00 06 01 05 00 03 FF 00</li></ul><p><strong>0x0F：写多个线圈</strong></p><p>将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L 字节长度 输出值H 输出值L</li><li>响应：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L</li></ul><p><strong>0x02：读离散量输入</strong></p><p>从一个从站中读1~2000个连续的离散量输入状态</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 数据（长度：9+ceil（数量/8））</li><li>如：从地址0x0000开始读0x0012个离散量输入<br>00 01 00 00 00 06 01 02 00 00 00 12</li><li>回：数据长度为0x03个字节，数据为0x01 04 00，表示第一个离散量输入和第11个离散量输入为ON，其余为OFF<br>00 01 00 00 00 06 01 02 03 01 04 00</li></ul><p><strong>0x04：读输入寄存器</strong></p><p>从一个远程设备中读1~2000个连续输入寄存器</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</li><li>如：读起始地址为0x0002，数量为0x0005的寄存器数据<br>00 01 00 00 00 06 01 04 00 02 00 05</li><li>回：数据长度为0x0A，第一个寄存器的数据为0x0c，其余为0x00<br>00 01 00 00 00 0D 01 04 0A 00 0C 00 00 00 00 00 00 00 00</li></ul><p><strong>0x03：读保持寄存器</strong></p><p>从远程设备中读保持寄存器连续块的内容</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li><li>响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</li><li>如：起始地址是0x0000，寄存器数量是 0x0003<br>00 01 00 00 00 06 01 03 00 00 00 03</li><li>回：数据长度为0x06，第一个寄存器的数据为0x21，其余为0x00<br>00 01 00 00 00 09 01 03 06 00 21 00 00 00 00</li></ul><p><strong>0x06：写单个保持寄存器</strong></p><p>在一个远程设备中写一个保持寄存器</p><ul><li>请求：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</li><li>响应：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</li><li>如：向地址是0x0000的寄存器写入数据0x000A<br>00 01 00 00 00 06 01 06 00 00 00 0A</li><li>回：写入成功<br>00 01 00 00 00 06 01 06 00 00 00 0A</li></ul><p><strong>0x10：写多个保持寄存器</strong></p><p>在一个远程设备中写连续寄存器块（1~123个寄存器）</p><ul><li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L 字节长度 寄存器值（13+寄存器数量×2）</li><li>响应：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li><li>如：向起始地址为0x0000，数量为0x0001的寄存器写入数据，数据长度为0x02，数据为0x000F<br>00 01 00 00 00 09 01 10 00 00 00 01 02 00 0F</li><li>回：写入成功<br>00 01 00 00 00 06 01 10 00 00 00 01</li></ul><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    HOST = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    TCP_IP = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    TCP_PORT = <span class="number">502</span></span><br><span class="line">    MaxBytes = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建socket连接</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.connect((TCP_IP, TCP_PORT))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>, e)</span><br><span class="line">        s.close()</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接成功</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;have connected with server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 十进制、十六进制都可以</span></span><br><span class="line">    <span class="comment"># 示例为写一个保持寄存器</span></span><br><span class="line">    arr = [<span class="number">00</span>, <span class="number">1</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">0x0A</span>]</span><br><span class="line">    data = struct.pack(<span class="string">&quot;%dB&quot;</span> % (<span class="built_in">len</span>(arr)), *arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s.settimeout(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># s.sendall(data) 发送数据包</span></span><br><span class="line">        sendBytes = s.send(data)</span><br><span class="line">        <span class="keyword">if</span> sendBytes &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接受响应信息</span></span><br><span class="line">        recvData = s.recv(MaxBytes)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> recvData:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;接收数据为空，我要退出了&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        localTime = time.asctime(time.localtime(time.time()))</span><br><span class="line">        <span class="built_in">print</span>(localTime, <span class="string">&#x27; 接收到数据字节数:&#x27;</span>, <span class="built_in">len</span>(recvData))</span><br><span class="line">        <span class="built_in">print</span>(struct.unpack(<span class="string">&quot;%dB&quot;</span> % (<span class="built_in">len</span>(recvData)), recvData))</span><br><span class="line"></span><br><span class="line">        localTime = time.asctime(time.localtime(time.time()))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    s.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已经退出了，后会无期&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Modbus-TCP-示例报文"><a href="#Modbus-TCP-示例报文" class="headerlink" title="Modbus TCP 示例报文"></a>Modbus TCP 示例报文</h2><p>ModBusTcp与串行链路Modbus的数据域是一致的，具体数据域可以参考串行Modbus。这里给出几个ModbusTcp的链路解析说明，辅助新人分析报文。</p><p><img src="https://img2018.cnblogs.com/blog/1049945/201905/1049945-20190508105024867-1465971698.png"></p><center>图2 数据请求示例</center><p><img src="https://img2018.cnblogs.com/blog/1049945/201905/1049945-20190508105040049-1499833761.png"></p><center>图3 数据请求的回复示例</center><p><img src="https://img2018.cnblogs.com/blog/1049945/201905/1049945-20190508105058898-1473882489.png"></p><center>图4 写多个寄存器示例</center><p><img src="https://img2018.cnblogs.com/blog/1049945/201905/1049945-20190508105113300-464011136.png"></p><center>图5 写多个寄存器的响应示例</center><blockquote><p>功能码 0x10：写多个保持寄存器。上面图片3和图片4都写错了。</p></blockquote><h2 id="ModbusTCP通信"><a href="#ModbusTCP通信" class="headerlink" title="ModbusTCP通信"></a>ModbusTCP通信</h2><p><strong>通信方式</strong></p><p>Modbus设备可分为主站(poll)和从站(slave)。主站只有一个，从站有多个，主站向各从站发送请求帧，从站给予响应。在使用TCP通信时，主站为client端，主动建立连接；从站为server端，等待连接。</p><ul><li>主站请求：功能码+数据</li><li>从站正常响应：请求功能码+响应数据</li><li>从站异常响应：异常功能码+异常码，其中异常功能码即将请求功能码的最高有效位置1，异常码指示差错类型</li><li><strong>注意：需要超时管理机制，避免无期限的等待可能不出现的应答</strong></li></ul><p>IANA（Internet Assigned Numbers Authority，互联网编号分配管理机构）给Modbus协议赋予TCP端口号为<strong>502</strong>，这是目前在仪表与自动化行业中唯一分配到的端口号。</p><p><strong>通信过程</strong></p><ol><li>connect 建立TCP连接</li><li>准备Modbus报文</li><li>使用send命令发送报文</li><li>在同一连接下等待应答</li><li>使用recv命令读取报文，完成一次数据交换</li><li>通信任务结束时，关闭TCP连接</li></ol><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在工业自动化控制中，经常会遇到开关量，数字量，模拟量，离散量，脉冲量等各种概念，而人们在实际应用中，对于这些概念又很容易混淆。现将各种概念罗列如下：</p><p><strong>1.开关量：</strong></p><p>一般指的是触点的“开”与“关”的状态，一般在计算机设备中也会用“0”或“1”来表示开关量的状态。开关量分为有源开关量信号和无源开关量信号，有源开关量信号指的是“开”与“关”的状态是带电源的信号，专业叫法为跃阶信号，可以理解为脉冲量，一般的都有220VAC, 110VAC,24VDC,12VDC等信号，无源开关量信号指的是“开”和“关”的状态时不带电源的信号，一般又称之为干接点。电阻测试法为电阻0或无穷大。</p><p><strong>2.数字量：</strong></p><p>很多人会将数字量与开关量混淆，也将其与模拟量混淆。数字量在时间和数量上都是离散的物理量，其表示的信号则为数字信号。数字量是由0和1组成的信号，经过编码形成有规律的信号，量化后的模拟量就是数字量。</p><p><strong>3.模拟量：</strong></p><p>模拟量的概念与数字量相对应，但是经过量化之后又可以转化为数字量。模拟量是在时间和数量上都是连续的物理量，其表示的信号则为模拟信号。模拟量在连续的变化过程中任何一个取值都是一个具体有意义的物理量，如温度，电压，电流等。</p><p><strong>4.离散量：</strong></p><p>离散量是将模拟量离散化之后得到的物理量。即任何仪器设备对于模拟量都不可能有个完全精确的表示，因为他们都有一个采样周期，在该采样周期内，其物理量的数值都是不变的，而实际上的模拟量则是变化的。这样就将模拟量离散化，成为了离散量。</p><p><strong>5.脉冲量：</strong></p><p>脉冲量就是瞬间电压或电流由某一值跃变到另一值的信号量。在量化后，其变化持续有规律就是数字量，如果其由0变成某一固定值并保持不变，其就是开关量。</p><blockquote><p>综上所述，模拟量就是在某个过程中时间和数量连续变化的物理量，由于在实际的应用中，所有的仪器设备对于外界数据的采集都有一个采样周期，其采集的数据只有在下一个采样周期开始时才有变动，采样周期内其数值并不随模拟量的变化而变动。</p><p>这样就将模拟量离散化了，例如：某设备的采样周期为1秒，其在第五秒的时间采集的温度为35度，而第六秒的温度为36度，该设备就只能标称第五秒时间温度35度，第六秒时间温度36度，而第五点五秒的时间其标称也只是35度，但是其实际的模拟量是35.5度。这样就将模拟信号离散化。其采集的数据就是离散化了，不再是连续的模拟量信号。</p><p>由于计算机只识别0和1两个信号，即开关量信号，用其来表示数值都是使用数字串来表示，由于计算能力的问题，其数字串不能无限长，即其表达的精度也是有限的，同样的以温度为例，由于数字串限制，其表达温度的精度只能达到0.1度，小于该单位的数值则不能被标称，这样就必须将离散量进行量化，将其变为数字量。即35.68度的温度则表示为35.6度。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/ioufev/articles/10830028.html&quot;&gt;ModbusTCP协议 - ioufev - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="protocol" scheme="https://yingyingmonstre.github.io/categories/protocol/"/>
    
    
    <category term="Modbus" scheme="https://yingyingmonstre.github.io/tags/Modbus/"/>
    
    <category term="protocol" scheme="https://yingyingmonstre.github.io/tags/protocol/"/>
    
  </entry>
  
</feed>
