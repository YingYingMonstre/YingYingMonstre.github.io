<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MacBook Air M1安装gym问题汇总</title>
    <url>/YingYingMonstre.github.io/2021/11/03/MacBook%20Air%20M1%E5%AE%89%E8%A3%85gym%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>安装gym花了一天时间，中途出了很多问题，特此记录。</p>
<p><strong>0. 关于本机</strong></p>
<ul>
<li>macOS Monterey版本12.0.1</li>
<li>MacBook Air（M1，2020）</li>
<li>芯片 Apple M1</li>
</ul>
<p><strong>1. 环境相关</strong></p>
<p>创建pycharm环境参考文章：<a href="https://zhuanlan.zhihu.com/p/410961551">https://zhuanlan.zhihu.com/p/410961551</a></p>
<p><strong>2. 下载gym</strong></p>
<p>可以直接在终端上pip install gym，但是在pycharm中使用时会报错缺一些组件，比如No module named ‘pyglet’。本人使用的是下边的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;openai&#x2F;gym.git</span><br><span class="line"></span><br><span class="line">cd gym</span><br><span class="line"></span><br><span class="line">pip install -e &#39;.[all]&#39;</span><br></pre></td></tr></table></figure>



<p><strong>3. No matching distribution found for ale-py~=0.7.1 (from gym==0.21.0)</strong></p>
<p>问题状况：在问题2中pip install -e ‘.[all]’时报错。</p>
<p>解决方法：直接pip install ale-py，如果不能下载（具体报错的原因忘了），尝试conda update pip，我是在更新完pip后可以下载的。</p>
<p><strong>4. unable to execute ‘swig’: No such file or directory</strong></p>
<p>问题状况：解决了第3步的问题后，在pip install -e ‘.[all]’过程中出现。</p>
<p>解决方法：brew install swig</p>
<p><strong>5. zsh: command not found: brew</strong></p>
<p>问题状况：在第4步输入brew install swig后报错。</p>
<p>解决方法：mac安装homebrew，</p>
<p>用以下命令安装，序列号选择中科大（1）的</p>
<p>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</a></p>
<p>原文地址：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/wangyun71/article/details/108560873">https://blog.csdn.net/wangyun71/article/details/108560873</a></p>
<p><strong>6. from . import multiarray等</strong></p>
<p>问题状况：在解决了第4、5步的问题后继续运行pip install -e ‘.[all]’，成功安装。但是在测试用例代码时报的错误。提示检查python和numpy的版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v0&#x27;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    env.render()</span><br><span class="line">    env.step(env.action_space.sample()) <span class="comment"># take a random action</span></span><br></pre></td></tr></table></figure>

<p>解决方法：重新安装了numpy之后就可以用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip uninstall numpy</span><br><span class="line"></span><br><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>



<p><strong>7. zsh:killed</strong></p>
<p>问题状况：偶然遇到的，在conda activate环境后不能用clear、pip等命令，不知道是什么原因。</p>
<p>解决方法：删除环境重新搭建环境就可以了</p>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ModbusTCP协议学习</title>
    <url>/YingYingMonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Modbus由MODICON公司于1979年开发，是一种<strong>工业现场总线</strong>协议标准。1996年<strong>施耐德</strong>公司推出基于<strong>以太网TCP/IP</strong>的Modbus协议：<strong>Modbus TCP</strong>。</p>
<p>Modbus协议是一项应用层报文传输协议，包括ASCII、RTU、<strong>TCP</strong>三种报文类型。</p>
<p>标准的Modbus协议物理层接口有RS232、RS422、RS485和<strong>以太网</strong>接口，采用<strong>master/slave</strong>方式通信。</p>
<h3 id="Modbus-TCP数据帧"><a href="#Modbus-TCP数据帧" class="headerlink" title="Modbus TCP数据帧"></a>Modbus TCP数据帧</h3><p>Modbus TCP的数据帧可分为两部分：<strong>MBAP</strong>+<strong>PDU</strong>。其协议特征如图所示。</p>
<img src="/YingYingMonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/feature.png" class="">

<center>Modbus TCP协议特征</center>

<h4 id="报文头MBAP"><a href="#报文头MBAP" class="headerlink" title="报文头MBAP"></a>报文头MBAP</h4><p>MBAP为报文头，长度为7字节，组成如下：</p>
<table>
<thead>
<tr>
<th align="left">事务处理标识</th>
<th align="left">协议标识</th>
<th align="left">长度</th>
<th align="left">单元标识符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2字节</td>
<td align="left">2字节</td>
<td align="left">2字节</td>
<td align="left">1字节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>事务处理标识</strong></td>
<td>可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文。</td>
</tr>
<tr>
<td><strong>协议标识符</strong></td>
<td>00 00表示Modbus TCP协议。</td>
</tr>
<tr>
<td><strong>长度</strong></td>
<td>表示接下来的数据长度，单位为字节。</td>
</tr>
<tr>
<td><strong>单元标识符</strong></td>
<td>可以理解为设备地址。</td>
</tr>
</tbody></table>
<h4 id="帧结构PDU"><a href="#帧结构PDU" class="headerlink" title="帧结构PDU"></a>帧结构PDU</h4><p>PDU由<strong>功能码+数据</strong>组成。功能码为1字节，数据长度不定，由具体功能决定。</p>
<p><strong>功能码</strong></p>
<p>Modbus的操作对象有四种：线圈、离散输入、保持寄存器、输入寄存器。</p>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线圈</td>
<td align="center">PLC的输出位，开关量，在Modbus中可读可写</td>
</tr>
<tr>
<td align="center">离散量</td>
<td align="center">PLC的输入位，开关量，在Modbus中只读</td>
</tr>
<tr>
<td align="center">输入寄存器</td>
<td align="center">PLC中只能从模拟量输入端改变的寄存器，在Modbus中只读</td>
</tr>
<tr>
<td align="center">保持寄存器</td>
<td align="center">PLC中用于输出模拟量信号的寄存器，在Modbus中可读可写</td>
</tr>
</tbody></table>
<p>根据对象的不同，Modbus的功能码有：</p>
<table>
<thead>
<tr>
<th align="center">功能码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01</td>
<td align="center">读线圈</td>
</tr>
<tr>
<td align="center">0x05</td>
<td align="center">写单个线圈</td>
</tr>
<tr>
<td align="center">0x0F</td>
<td align="center">写多个线圈</td>
</tr>
<tr>
<td align="center">0x02</td>
<td align="center">读离散量输入</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">读输入寄存器</td>
</tr>
<tr>
<td align="center">0x03</td>
<td align="center">读保持寄存器</td>
</tr>
<tr>
<td align="center">0x06</td>
<td align="center">写单个保持寄存器</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">写多个保持寄存器</td>
</tr>
</tbody></table>
<p>说明更详细的表</p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">中文名称</th>
<th align="center">英文名</th>
<th align="center">位操作/字操作</th>
<th align="center">操作数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">读线圈状态</td>
<td align="center">READ COIL STATUS</td>
<td align="center">位操作</td>
<td align="center">单个或多个</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">读离散输入状态</td>
<td align="center">READ INPUT STATUS</td>
<td align="center">位操作</td>
<td align="center">单个或多个</td>
</tr>
<tr>
<td align="center">03</td>
<td align="center">读保持寄存器</td>
<td align="center">READ HOLDING REGISTER</td>
<td align="center">字操作</td>
<td align="center">单个或多个</td>
</tr>
<tr>
<td align="center">04</td>
<td align="center">读输入寄存器</td>
<td align="center">READ INPUT REGISTER</td>
<td align="center">字操作</td>
<td align="center">单个或多个</td>
</tr>
<tr>
<td align="center">05</td>
<td align="center">写线圈状态</td>
<td align="center">WRITE SINGLE COIL</td>
<td align="center">位操作</td>
<td align="center">单个</td>
</tr>
<tr>
<td align="center">06</td>
<td align="center">写单个保持寄存器</td>
<td align="center">WRITE SINGLE REGISTER</td>
<td align="center">字操作</td>
<td align="center">单个</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">写多个线圈</td>
<td align="center">WRITE MULTIPLE COIL</td>
<td align="center">位操作</td>
<td align="center">多个</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">写多个保持寄存器</td>
<td align="center">WRITE MULTIPLE REGISTER</td>
<td align="center">字操作</td>
<td align="center">多个</td>
</tr>
</tbody></table>
<h3 id="PDU详细结构"><a href="#PDU详细结构" class="headerlink" title="PDU详细结构"></a>PDU详细结构</h3><p>测试软件：mod_RSsim5.3</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">对应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线圈</td>
<td align="center">Coil Outputs</td>
</tr>
<tr>
<td align="center">离散量</td>
<td align="center">Digital Inputs</td>
</tr>
<tr>
<td align="center">输入寄存器</td>
<td align="center">Analogue Inputs</td>
</tr>
<tr>
<td align="center">保持寄存器</td>
<td align="center">Holding Registers</td>
</tr>
</tbody></table>
<h4 id="0x01：读线圈"><a href="#0x01：读线圈" class="headerlink" title="0x01：读线圈"></a><strong>0x01：读线圈</strong></h4><p>在从站中读1~2000个连续线圈状态，ON=1,OFF=0</p>
<ul>
<li>请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</li>
<li>响应：MBAP 功能码 数据长度 数据（一个地址的数据为1位）</li>
<li>如：在从站0x01中，读取开始地址为0x0002的线圈数据，读0x0008位<br>00 01 00 00 00 06 01 01 00 02 00 08</li>
<li>回：数据长度为0x01个字节，数据为0x01，第一个线圈为ON，其余为OFF<br>00 01 00 00 00 04 01 01 01 01</li>
</ul>
<h4 id="0x05：写单个线圈"><a href="#0x05：写单个线圈" class="headerlink" title="0x05：写单个线圈"></a><strong>0x05：写单个线圈</strong></h4><p>将从站中的一个输出写成ON或OFF，0xFF00请求输出为ON,0x000请求输出为OFF</p>
<ul>
<li>请求：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</li>
<li>响应：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）</li>
<li>如：将地址为0x0003的线圈设为ON<br>00 01 00 00 00 06 01 05 00 03 FF 00</li>
<li>回：写入成功<br>00 01 00 00 00 06 01 05 00 03 FF 00</li>
</ul>
<h4 id="0x0F：写多个线圈"><a href="#0x0F：写多个线圈" class="headerlink" title="0x0F：写多个线圈"></a><strong>0x0F：写多个线圈</strong></h4><p>将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF</p>
<ul>
<li>请求：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L 字节长度 输出值H 输出值L</li>
<li>响应：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L</li>
</ul>
<h4 id="0x02：读离散量输入"><a href="#0x02：读离散量输入" class="headerlink" title="0x02：读离散量输入"></a><strong>0x02：读离散量输入</strong></h4><p>从一个从站中读1~2000个连续的离散量输入状态</p>
<ul>
<li>请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）</li>
<li>响应：MBAP 功能码 数据长度 数据（长度：9+ceil（数量/8））</li>
<li>如：从地址0x0000开始读0x0012个离散量输入<br>00 01 00 00 00 06 01 02 00 00 00 12</li>
<li>回：数据长度为0x03个字节，数据为0x01 04 00，表示第一个离散量输入和第11个离散量输入为ON，其余为OFF<br>00 01 00 00 00 06 01 02 03 01 04 00</li>
</ul>
<h4 id="0x04：读输入寄存器"><a href="#0x04：读输入寄存器" class="headerlink" title="0x04：读输入寄存器"></a><strong>0x04：读输入寄存器</strong></h4><p>从一个远程设备中读1~2000个连续输入寄存器</p>
<ul>
<li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li>
<li>响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</li>
<li>如：读起始地址为0x0002，数量为0x0005的寄存器数据<br>00 01 00 00 00 06 01 04 00 02 00 05</li>
<li>回：数据长度为0x0A，第一个寄存器的数据为0x0c，其余为0x00<br>00 01 00 00 00 0D 01 04 0A 00 0C 00 00 00 00 00 00 00 00</li>
</ul>
<h4 id="0x03：读保持寄存器"><a href="#0x03：读保持寄存器" class="headerlink" title="0x03：读保持寄存器"></a><strong>0x03：读保持寄存器</strong></h4><p>从远程设备中读保持寄存器连续块的内容</p>
<ul>
<li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li>
<li>响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)</li>
<li>如：起始地址是0x0000，寄存器数量是 0x0003<br>00 01 00 00 00 06 01 03 00 00 00 03</li>
<li>回：数据长度为0x06，第一个寄存器的数据为0x21，其余为0x00<br>00 01 00 00 00 09 01 03 06 00 21 00 00 00 00</li>
</ul>
<h4 id="0x06：写单个保持寄存器"><a href="#0x06：写单个保持寄存器" class="headerlink" title="0x06：写单个保持寄存器"></a><strong>0x06：写单个保持寄存器</strong></h4><p>在一个远程设备中写一个保持寄存器</p>
<ul>
<li>请求：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</li>
<li>响应：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）</li>
<li>如：向地址是0x0000的寄存器写入数据0x000A<br>00 01 00 00 00 06 01 06 00 00 00 0A</li>
<li>回：写入成功<br>00 01 00 00 00 06 01 06 00 00 00 0A</li>
</ul>
<h4 id="0x10：写多个保持寄存器"><a href="#0x10：写多个保持寄存器" class="headerlink" title="0x10：写多个保持寄存器"></a><strong>0x10：写多个保持寄存器</strong></h4><p>在一个远程设备中写连续寄存器块（1~123个寄存器）</p>
<ul>
<li>请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L 字节长度 寄存器值（13+寄存器数量×2）</li>
<li>响应：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）</li>
<li>如：向起始地址为0x0000，数量为0x0001的寄存器写入数据，数据长度为0x02，数据为0x000F<br>00 01 00 00 00 09 01 10 00 00 00 01 02 00 0F</li>
<li>回：写入成功<br>00 01 00 00 00 06 01 10 00 00 00 01</li>
</ul>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    HOST = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    TCP_IP = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    TCP_PORT = <span class="number">502</span></span><br><span class="line">    MaxBytes = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建socket连接</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.connect((TCP_IP, TCP_PORT))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>, e)</span><br><span class="line">        s.close()</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接成功</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;have connected with server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 十进制、十六进制都可以</span></span><br><span class="line">    <span class="comment"># 示例为写一个保持寄存器</span></span><br><span class="line">    arr = [<span class="number">00</span>, <span class="number">1</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">0x0A</span>]</span><br><span class="line">    data = struct.pack(<span class="string">&quot;%dB&quot;</span> % (<span class="built_in">len</span>(arr)), *arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s.settimeout(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># s.sendall(data) 发送数据包</span></span><br><span class="line">        sendBytes = s.send(data)</span><br><span class="line">        <span class="keyword">if</span> sendBytes &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接受响应信息</span></span><br><span class="line">        recvData = s.recv(MaxBytes)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> recvData:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;接收数据为空，我要退出了&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        localTime = time.asctime(time.localtime(time.time()))</span><br><span class="line">        <span class="built_in">print</span>(localTime, <span class="string">&#x27; 接收到数据字节数:&#x27;</span>, <span class="built_in">len</span>(recvData))</span><br><span class="line">        <span class="built_in">print</span>(struct.unpack(<span class="string">&quot;%dB&quot;</span> % (<span class="built_in">len</span>(recvData)), recvData))</span><br><span class="line"></span><br><span class="line">        localTime = time.asctime(time.localtime(time.time()))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    s.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已经退出了，后会无期&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="Modbus-TCP-示例报文"><a href="#Modbus-TCP-示例报文" class="headerlink" title="Modbus TCP 示例报文"></a>Modbus TCP 示例报文</h3><p>ModBusTcp与串行链路Modbus的数据域是一致的，具体数据域可以参考串行Modbus。这里给出几个ModbusTcp的链路解析说明，辅助新人分析报文。</p>
<img src="/YingYingMonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/test1.png" class="">

<img src="/YingYingMonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/test2.png" class="">

<img src="/YingYingMonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/test3.png" class="">

<img src="/YingYingMonstre.github.io/2021/09/17/ModbusTCP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/test4.png" class="">

<blockquote>
<p>功能码 0x10：写多个保持寄存器。上面图片3和图片4都写错了。</p>
</blockquote>
<h3 id="ModbusTCP通信"><a href="#ModbusTCP通信" class="headerlink" title="ModbusTCP通信"></a>ModbusTCP通信</h3><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a><strong>通信方式</strong></h4><p>Modbus设备可分为主站(poll)和从站(slave)。主站只有一个，从站有多个，主站向各从站发送请求帧，从站给予响应。在使用TCP通信时，主站为client端，主动建立连接；从站为server端，等待连接。</p>
<ul>
<li>主站请求：功能码+数据</li>
<li>从站正常响应：请求功能码+响应数据</li>
<li>从站异常响应：异常功能码+异常码，其中异常功能码即将请求功能码的最高有效位置1，异常码指示差错类型</li>
<li><strong>注意：需要超时管理机制，避免无期限的等待可能不出现的应答</strong></li>
</ul>
<p>IANA（Internet Assigned Numbers Authority，互联网编号分配管理机构）给Modbus协议赋予TCP端口号为<strong>502</strong>，这是目前在仪表与自动化行业中唯一分配到的端口号。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a><strong>通信过程</strong></h4><ol>
<li>connect 建立TCP连接</li>
<li>准备Modbus报文</li>
<li>使用send命令发送报文</li>
<li>在同一连接下等待应答</li>
<li>使用recv命令读取报文，完成一次数据交换</li>
<li>通信任务结束时，关闭TCP连接</li>
</ol>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>在工业自动化控制中，经常会遇到开关量，数字量，模拟量，离散量，脉冲量等各种概念，而人们在实际应用中，对于这些概念又很容易混淆。现将各种概念罗列如下：</p>
<p><strong>1.开关量：</strong></p>
<p>一般指的是触点的“开”与“关”的状态，一般在计算机设备中也会用“0”或“1”来表示开关量的状态。开关量分为有源开关量信号和无源开关量信号，有源开关量信号指的是“开”与“关”的状态是带电源的信号，专业叫法为跃阶信号，可以理解为脉冲量，一般的都有220VAC, 110VAC,24VDC,12VDC等信号，无源开关量信号指的是“开”和“关”的状态时不带电源的信号，一般又称之为干接点。电阻测试法为电阻0或无穷大。</p>
<p><strong>2.数字量：</strong></p>
<p>很多人会将数字量与开关量混淆，也将其与模拟量混淆。数字量在时间和数量上都是离散的物理量，其表示的信号则为数字信号。数字量是由0和1组成的信号，经过编码形成有规律的信号，量化后的模拟量就是数字量。</p>
<p><strong>3.模拟量：</strong></p>
<p>模拟量的概念与数字量相对应，但是经过量化之后又可以转化为数字量。模拟量是在时间和数量上都是连续的物理量，其表示的信号则为模拟信号。模拟量在连续的变化过程中任何一个取值都是一个具体有意义的物理量，如温度，电压，电流等。</p>
<p><strong>4.离散量：</strong></p>
<p>离散量是将模拟量离散化之后得到的物理量。即任何仪器设备对于模拟量都不可能有个完全精确的表示，因为他们都有一个采样周期，在该采样周期内，其物理量的数值都是不变的，而实际上的模拟量则是变化的。这样就将模拟量离散化，成为了离散量。</p>
<p><strong>5.脉冲量：</strong></p>
<p>脉冲量就是瞬间电压或电流由某一值跃变到另一值的信号量。在量化后，其变化持续有规律就是数字量，如果其由0变成某一固定值并保持不变，其就是开关量。</p>
<blockquote>
<p>综上所述，模拟量就是在某个过程中时间和数量连续变化的物理量，由于在实际的应用中，所有的仪器设备对于外界数据的采集都有一个采样周期，其采集的数据只有在下一个采样周期开始时才有变动，采样周期内其数值并不随模拟量的变化而变动。</p>
<p>这样就将模拟量离散化了，例如：某设备的采样周期为1秒，其在第五秒的时间采集的温度为35度，而第六秒的温度为36度，该设备就只能标称第五秒时间温度35度，第六秒时间温度36度，而第五点五秒的时间其标称也只是35度，但是其实际的模拟量是35.5度。这样就将模拟信号离散化。其采集的数据就是离散化了，不再是连续的模拟量信号。</p>
<p>由于计算机只识别0和1两个信号，即开关量信号，用其来表示数值都是使用数字串来表示，由于计算能力的问题，其数字串不能无限长，即其表达的精度也是有限的，同样的以温度为例，由于数字串限制，其表达温度的精度只能达到0.1度，小于该单位的数值则不能被标称，这样就必须将离散量进行量化，将其变为数字量。即35.68度的温度则表示为35.6度。</p>
</blockquote>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="https://www.cnblogs.com/ioufev/articles/10830028.html">ModbusTCP协议 - ioufev - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>Modbus</tag>
      </tags>
  </entry>
  <entry>
    <title>XCTF-Web基础篇</title>
    <url>/YingYingMonstre.github.io/2021/09/26/XCTF-Web%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h2><p>方法一：不能用右键审查元素，则按F12打开开发者工具查看，找到flag</p>
<p>方法二：在url中通过view-source:的方法来访问源码，在url中提交view-source:+url</p>
<p>方法三：通过Burpsuite抓包查看源代码</p>
<h2 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h2><p>[原理]</p>
<p>robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p>
<p>[步骤]</p>
<p>1.根据提示robots,可以直接想到robots.txt</p>
<p>2.或通过扫目录也可以扫到: <code>python dirsearch.py -u http://10.10.10.175:32793/ -e *</code>（这个脚本在cmd中可以用，git bash不行）</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/robots/1.png" alt="img"></p>
<p>3.访问<code>http://111.198.29.45:33982/robots.txt</code>发现<code>f1ag_1s_h3re.php</code></p>
<p>4.访问<code>http://111.198.29.45:33982/f1ag_1s_h3re.php</code>得到flag</p>
<h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><p><strong>[目标]</strong></p>
<p>掌握有关备份文件的知识</p>
<p>常见的备份文件后缀名有: <code>.git .svn .swp .svn .~ .bak .bash_history</code></p>
<p><strong>[环境]</strong></p>
<p>无</p>
<p><strong>[工具]</strong></p>
<p>扫目录脚本dirsearch(项目地址：<code>https://github.com/maurosoria/dirsearch</code>(<code>https://github.com/maurosoria/dirsearch</code>))</p>
<p><strong>[步骤]</strong></p>
<p>1.可以手动猜测,也可以使用扫目录脚本/软件,扫一下,这里使用的是github上的脚本dirsearch,命令行下: <code>py python3 dirsearch.py -u http://10.10.10.175:32770 -e *</code></p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/backup/1.png" alt="img"></p>
<p>2.看到存在备份文件index.php.bak访问 <code>http://10.10.10.175:32770/index.php.bak</code></p>
<p>3.保存到本地打开，即可看到flag</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>[原理]</p>
<p> Cookie是当主机访问Web服务器时，由 Web 服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。</p>
<p><strong>[目的]</strong></p>
<p>掌握有关cookie的知识，了解cookie所在位置</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox</p>
<p><strong>[步骤]</strong></p>
<p>1.浏览器按下F12键打开开发者工具，刷新后，在存储一栏，可看到名为look-here的cookie的值为cookie.php</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/cookie/1.png" alt="img"></p>
<p>2.访问<code>http://111.198.29.45:47911/cookie.php</code>，提示查看http响应包，在网络一栏，可看到访问cookie.php的数据包</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/cookie/2.png" alt="img"></p>
<p>3.点击查看数据包，在消息头内可发现flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/cookie/3.png" alt="img"></p>
<p>用dirsearch可以找到cookie.php文件，再用burpsuite抓包也可行。</p>
<h2 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h2><p><strong>[目标]</strong></p>
<p>初步了解前端知识</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox</p>
<p><strong>[步骤]</strong></p>
<p>1.打开开发者工具（得用火狐浏览器），在查看器窗口审查元素，发现存在disabled=””字段，</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/disabled_button/1.png" alt="img"></p>
<p>2.将<code>disabled=&quot;&quot;</code>删除后，按钮可按，按下后得到flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/disabled_button/2.png" alt="img"></p>
<p>3.或审计from表单代码，使用hackbar（不能用，现在收费了），用post方式传递auth=flag，同样可以获得flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/disabled_button/3.png" alt="img"></p>
<h2 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h2><p><strong>[目标]</strong></p>
<p>了解弱口令，掌握爆破方法</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<ul>
<li>burpsuite</li>
<li>字典<code>&lt;https://github.com/rootphantomer/Blasting_dictionary/blob/master/%E5%B8%B8%E7%94%A8%E5%AF%86%E7%A0%81.txt&gt;</code></li>
</ul>
<p><strong>[步骤]</strong></p>
<p>1.随便输入下用户名和密码,提示要用admin用户登入,然后跳转到了check.php,查看下源代码提示要用字典。</p>
<p>2.用burpsuite截下登录的数据包,把数据包发送到intruder爆破</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/weak_auth/1.png" alt="img"></p>
<p>2.设置爆破点为password</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/weak_auth/2.png" alt="img"></p>
<p>3.加载字典</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/weak_auth/3.png" alt="img"></p>
<p>4.开始攻击，查看响应包列表，发现密码为123456时，响应包的长度和别的不一样.</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/weak_auth/4.png" alt="img"></p>
<p>5.点进去查看响应包，获得flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/weak_auth/5.png" alt="img"></p>
<h2 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h2><p><strong>[原理]</strong></p>
<p>php中有两种比较符号</p>
<p>=== 会同时比较字符串的值和类型</p>
<p>== 会先将字符串换成相同类型（先类型转换），再作比较，属于弱类型比较</p>
<p><strong>[目地]</strong></p>
<p>掌握php的弱类型比较</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox</p>
<p><strong>[步骤]</strong></p>
<p>1.打开页面，进行代码审计，发现同时满足 $a==0 和 $a 时，显示flag1。</p>
<p>2.php中的弱类型比较会使’abc’ == 0为真，所以输入a=abc时，可得到flag1，如图所示。（abc可换成任意字符）。</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple_php/1.png" alt="img"></p>
<p>3.is_numeric() 函数会判断如果是数字和数字字符串则返回 TRUE，否则返回 FALSE,且php中弱类型比较时，会使(‘1234a’ == 1234)为真，所以当输入a=abc&amp;b=1235a，可得到flag2，如图所示。==（数字和字符混合的字符串转换为整数后只保留数字）==</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple_php/2.png" alt="img"></p>
<p> php类型比较表<a href="https://www.php.net/manual/zh/types.comparisons.php%E3%80%82">https://www.php.net/manual/zh/types.comparisons.php。</a></p>
<h2 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h2><p><strong>[原理]</strong></p>
<p>HTTP工作原理</p>
<p><strong>[目的]</strong></p>
<p>掌握常用http请求方式</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox和cmd</p>
<p><strong>[步骤]</strong></p>
<p>GET请求在url后加?a=1即可</p>
<p>POST请求需要用curl POST -d “b=2” <a href="http://111.200.241.244:65197/?a=1">http://111.200.241.244:65197/?a=1</a></p>
<p>返回如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl: (6) Could not resolve host: POST</span><br><span class="line">﻿&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;POST&amp;GET&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;bootstrap&#x2F;3.0.3&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;请用GET方式提交一个名为a,值为1的变量&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;请再以POST方式随便提交一个名为b,值为2的变量&lt;&#x2F;h1&gt;&lt;h1&gt;cyberpeace&#123;51117d20e10dd8646f8d2eed10942e46&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>或者用burpsuite实现GET、POST的抓包：</p>
<p>GET的实现：在GET / HTTP/1.1中加入?a=1得到GET /?a=1 HTTP/1.1</p>
<p>POST的实现：GET / HTTP/1.1改为POST /?a=1 HTTP/1.1，在最下面（正文）加b=2，报文头加上Content-Type: application/x-www-form-urlencoded。</p>
<h2 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h2><p>[原理]</p>
<p>X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项</p>
<p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的</p>
<p><strong>[目的]</strong></p>
<p>掌握有关X-Forwarded-For和Referer的知识</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox、burpsuite</p>
<p><strong>[步骤]</strong></p>
<p>1.打开firefox和burp，使用burp对firefox进行代理拦截，在请求头添加<code>X-Forwarded-For: 123.123.123.123</code>，然后放包</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/xff_referer/1.png" alt="img"></p>
<p>2.接着继续在请求头内添加<code>Referer: https://www.google.com</code>，可获得flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/xff_referer/2.png" alt="img"></p>
<h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p><strong>[目标]</strong></p>
<p>了解php一句话木马、如何使用webshell</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox、hackbar</p>
<p>蚁剑下载地址<code>https://github.com/AntSwordProject/antSword/releases</code>(<code>https://github.com/AntSwordProject/antSword/releases</code>)</p>
<p><strong>[步骤]</strong></p>
<p>1.直接提示给了php一句话，可以用菜刀或蚁剑连接,此处用蚁剑链接:</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/webshell/1.png" alt="img"></p>
<p>2.连接后在网站目录下发现了flag.txt文件，查看文件可获得flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/webshell/2.png" alt="img"></p>
<p>3.也可以使用hackbar，使用post方式传递shell=system(‘cat flag.txt’); 获得flag</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/webshell/3.png" alt="img"></p>
<h2 id="command-execution"><a href="#command-execution" class="headerlink" title="command_execution"></a>command_execution</h2><p><strong>[原理]</strong></p>
<p>| 的作用为将前一个命令的结果传递给后一个命令作为输入</p>
<p>&amp;&amp;的作用是前一条命令执行成功时，才执行后一条命令</p>
<p><strong>[目地]</strong></p>
<p>掌握命令拼接的方法</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox</p>
<p><strong>[步骤]</strong></p>
<p>1.打开浏览器，在文本框内输入127.0.0.1 |  find / -name “flag.txt” （将 | 替换成 &amp; 或 &amp;&amp; 都可以）,查找flag所在位置，如图所示。</p>
<p>127.0.0.1 | ls ../../../可以找到一个home文件夹，里面有flag.txt文件。</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/command_execution/1.png" alt="img"></p>
<p>2.在文本框内输入 127.0.0.1 |  cat /home/flag.txt 可得到flag，如图所示。</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/command_execution/2.png" alt="img"></p>
<h2 id="simple-js"><a href="#simple-js" class="headerlink" title="simple_js"></a>simple_js</h2><p><strong>[原理]</strong></p>
<p>javascript的代码审计</p>
<p><strong>[目地]</strong></p>
<p>掌握简单的javascript函数</p>
<p><strong>[环境]</strong></p>
<p>windows</p>
<p><strong>[工具]</strong></p>
<p>firefox</p>
<p><strong>[步骤]</strong></p>
<p>1.打开页面，查看源代码，可以发现js代码，如图所示。</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple_js/1.png" alt="img"></p>
<p>2.进行代码审计，发现不论输入什么都会跳到假密码，真密码位于 fromCharCode 。</p>
<p>3.先将字符串用python处理一下，得到数组[55,56,54,79,115,69,114,116,107,49,50]，exp如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</span></span><br><span class="line"><span class="built_in">print</span> (s)</span><br></pre></td></tr></table></figure>

<p>4.将得到的数字分别进行ascii处理，可得到字符串786OsErtk12，exp如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a = [55,56,54,79,115,69,114,116,107,49,50]</span></span><br><span class="line"><span class="string">c = &quot;&quot;</span></span><br><span class="line"><span class="string">for i in a:</span></span><br><span class="line"><span class="string">    b = chr(i)</span></span><br><span class="line"><span class="string">    c = c + b</span></span><br><span class="line"><span class="string">print(c)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">string = <span class="string">&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37&quot;</span> \</span><br><span class="line">         <span class="string">&quot;\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31&quot;</span> \</span><br><span class="line">         <span class="string">&quot;\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">label = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">        label += <span class="built_in">chr</span>(count)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = count * <span class="number">10</span> + <span class="built_in">int</span>(i)</span><br><span class="line"></span><br><span class="line">label += <span class="built_in">chr</span>(count)</span><br><span class="line"><span class="built_in">print</span>(label)</span><br></pre></td></tr></table></figure>

<p>5.规范flag格式，可得到Cyberpeace{786OsErtk12}</p>
<h2 id="baby-web"><a href="#baby-web" class="headerlink" title="baby_web"></a>baby_web</h2><p><strong>【实验原理】</strong></p>
<p>web请求头中的location作用</p>
<p><strong>【实验目的】</strong></p>
<p>掌握web响应包头部常见参数</p>
<p><strong>【实验环境】</strong></p>
<p>Windows</p>
<p><strong>【实验工具】</strong></p>
<p>firefox</p>
<p><strong>【实验步骤】</strong></p>
<p>1.根据提示，在url中输入index.php,发现打开的仍然还是1.php</p>
<p>2.打开火狐浏览器的开发者模式，选择网络模块，再次请求index.php,查看返回包，可以看到location参数被设置了1.php，并且得到flag。</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/baby_web/1.png" alt="img"></p>
<p>我的：burpsuite抓包，看到有flag。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出理解什么是LLVM</title>
    <url>/YingYingMonstre.github.io/2021/12/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLLVM/</url>
    <content><![CDATA[<h3 id="什么是LLVM"><a href="#什么是LLVM" class="headerlink" title="什么是LLVM"></a>什么是<a href="https://llvm.org/">LLVM</a></h3><blockquote>
<p>LLVM项目是模块化、可重用的编译器以及工具链技术的集合。</p>
</blockquote>
<p>美国计算机协会 (ACM) 将其2012年软件系统奖项颁给了LLVM，之前曾经获得此奖项的软件和技术包括:Java、Apache、Mosaic、the World Wide Web、Smalltalk、UNIX、Eclipse等等。<br>创始人:Chris Lattner，亦是Swift之父。</p>
<blockquote>
<p>趣闻：Chris Latter本来只是想写一个底层的虚拟机，这也是LLVM名字的由来，low level virtual machine，跟Java的JVM虚拟机一样，可是后来，llvm从来没有被用作过虚拟机，哪怕LLVM的名气已经传开了。所以人们决定仍然叫他LLVM，更多的时候只是当作“商标”一样的感觉在使用，其实它跟虚拟机没有半毛钱关系。官方描述如下<br>The name “LLVM” itself is not an acronym; it is the full name of the project. “LLVM”这个名称本身不是首字母缩略词; 它是项目的全名。</p>
</blockquote>
<h3 id="传统的编译器架构"><a href="#传统的编译器架构" class="headerlink" title="传统的编译器架构"></a>传统的编译器架构</h3><img src="/YingYingMonstre.github.io/2021/12/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLLVM/traditional.jpg" class="">

<center>传统编译器架构</center>


<ul>
<li><strong>Frontend:前端</strong><br>词法分析、语法分析、语义分析、生成中间代码</li>
<li><strong>Optimizer:优化器</strong><br>中间代码优化</li>
<li><strong>Backend:后端</strong><br>生成机器码</li>
</ul>
<h3 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h3><img src="/YingYingMonstre.github.io/2021/12/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLLVM/llvm.png" class="">

<center>LLVM架构</center>

<ul>
<li><p>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</p>
</li>
<li><p>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</p>
</li>
<li><p>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</p>
</li>
<li><p>优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</p>
</li>
<li><p>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得特别困难</p>
</li>
<li><p>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)</p>
</li>
</ul>
<h3 id="什么是Clang"><a href="#什么是Clang" class="headerlink" title="什么是Clang"></a>什么是<a href="http://clang.llvm.org/">Clang</a></h3><p>LLVM项目的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端。</p>
<p><strong>相比于GCC，Clang具有如下优点</strong></p>
<ul>
<li>编译速度快:在某些平台上，Clang的编译速度显著的快过GCC(Debug模式下编译OC速度比GCC快3倍)</li>
<li>占用内存小:Clang生成的AST所占用的内存是GCC的五分之一左右</li>
<li>模块化设计:Clang采用基于库的模块化设计，易于 IDE 集成及其他用途的重用</li>
<li>诊断信息可读性强:在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告</li>
<li>设计清晰简单，容易理解，易于扩展增强</li>
</ul>
<h3 id="Clang与LLVM关系"><a href="#Clang与LLVM关系" class="headerlink" title="Clang与LLVM关系"></a>Clang与LLVM关系</h3><img src="/YingYingMonstre.github.io/2021/12/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLLVM/Clang-LLVM.png" class="">

<center>Clang与LLVM</center>

<p>LLVM整体架构，前端用的是clang，广义的LLVM是指整个LLVM架构，一般狭义的LLVM指的是LLVM后端（包含代码优化和目标代码生成）。</p>
<p>源代码（C/C++）经过clang–&gt; 中间代码(经过一系列的优化，优化用的是Pass) –&gt; 机器码</p>
<h3 id="OC源文件的编译过程"><a href="#OC源文件的编译过程" class="headerlink" title="OC源文件的编译过程"></a>OC源文件的编译过程</h3><p>这里用Xcode创建一个Test项目，然后cd到main.m的上一路径。<br>命令行查看编译的过程:$ clang -ccc-print-phases main.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ clang -ccc-print-phases main.m </span><br><span class="line"></span><br><span class="line">0: input, &quot;main.m&quot;, objective-c</span><br><span class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</span><br></pre></td></tr></table></figure>

<p>0.找到main.m文件<br>1.预处理器，处理include、import、宏定义<br>2.编译器编译，编译成ir中间代码<br>3.后端，生成目标代码<br>4.汇编<br>5.链接其他动态库、静态库<br>6.编译成适合某个架构的代码</p>
<p>查看preprocessor(预处理)的结果:$ clang -E main.m<br>这个命令敲出，终端就会打印许多信息，大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 &quot;main.m&quot;</span><br><span class="line"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class="line"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class="line"># 353 &quot;&lt;built-in&gt;&quot; 3</span><br><span class="line"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class="line"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class="line"># 1 &quot;main.m&quot; 2</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">  int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p><strong>词法分析</strong>，生成Token: $ clang -fmodules -E -Xclang -dump-tokens main.m<br>将代码分成一个个小单元（token）</p>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test(int a, int b)&#123;</span><br><span class="line">       int c &#x3D; a + b - 3;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void &#39;void&#39;  [StartOfLine]  Loc&#x3D;&lt;main.m:18:1&gt;</span><br><span class="line">identifier &#39;test&#39;    [LeadingSpace] Loc&#x3D;&lt;main.m:18:6&gt;</span><br><span class="line">l_paren &#39;(&#39;     Loc&#x3D;&lt;main.m:18:10&gt;</span><br><span class="line">int &#39;int&#39;       Loc&#x3D;&lt;main.m:18:11&gt;</span><br><span class="line">identifier &#39;a&#39;   [LeadingSpace] Loc&#x3D;&lt;main.m:18:15&gt;</span><br><span class="line">comma &#39;,&#39;       Loc&#x3D;&lt;main.m:18:16&gt;</span><br><span class="line">int &#39;int&#39;    [LeadingSpace] Loc&#x3D;&lt;main.m:18:18&gt;</span><br><span class="line">identifier &#39;b&#39;   [LeadingSpace] Loc&#x3D;&lt;main.m:18:22&gt;</span><br><span class="line">r_paren &#39;)&#39;     Loc&#x3D;&lt;main.m:18:23&gt;</span><br><span class="line">l_brace &#39;&#123;&#39;     Loc&#x3D;&lt;main.m:18:24&gt;</span><br><span class="line">int &#39;int&#39;    [StartOfLine] [LeadingSpace]   Loc&#x3D;&lt;main.m:19:5&gt;</span><br><span class="line">identifier &#39;c&#39;   [LeadingSpace] Loc&#x3D;&lt;main.m:19:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39;    [LeadingSpace] Loc&#x3D;&lt;main.m:19:11&gt;</span><br><span class="line">identifier &#39;a&#39;   [LeadingSpace] Loc&#x3D;&lt;main.m:19:13&gt;</span><br><span class="line">plus &#39;+&#39;     [LeadingSpace] Loc&#x3D;&lt;main.m:19:15&gt;</span><br><span class="line">identifier &#39;b&#39;   [LeadingSpace] Loc&#x3D;&lt;main.m:19:17&gt;</span><br><span class="line">minus &#39;-&#39;    [LeadingSpace] Loc&#x3D;&lt;main.m:19:19&gt;</span><br><span class="line">numeric_constant &#39;3&#39;     [LeadingSpace] Loc&#x3D;&lt;main.m:19:21&gt;</span><br><span class="line">semi &#39;;&#39;        Loc&#x3D;&lt;main.m:19:22&gt;</span><br><span class="line">r_brace &#39;&#125;&#39;  [StartOfLine]  Loc&#x3D;&lt;main.m:20:1&gt;</span><br><span class="line">eof &#39;&#39;      Loc&#x3D;&lt;main.m:20:2&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出，词法分析的时候，将上面的代码拆分一个个token，后面数字表示某一行的第几个字符，例如第一个void，表示第18行第一个字符。</p>
<h3 id="语法树-AST"><a href="#语法树-AST" class="headerlink" title="语法树-AST"></a>语法树-AST</h3><p>语法分析，生成语法树(AST，Abstract Syntax Tree): $ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m<br>通过语法树，我们能知道这个代码是做什么的。</p>
<p>还是刚刚的test函数<br>生成语法树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-FunctionDecl 0x7fa1439f5630 &lt;line:18:1, line:20:1&gt; line:18:6 test &#39;void (int, int)&#39;</span><br><span class="line">| |-ParmVarDecl 0x7fa1439f54b0 &lt;col:11, col:15&gt; col:15 used a &#39;int&#39;</span><br><span class="line">| |-ParmVarDecl 0x7fa1439f5528 &lt;col:18, col:22&gt; col:22 used b &#39;int&#39;</span><br><span class="line">| &#96;-CompoundStmt 0x7fa142167c88 &lt;col:24, line:20:1&gt;</span><br><span class="line">|   &#96;-DeclStmt 0x7fa142167c70 &lt;line:19:5, col:22&gt;</span><br><span class="line">|     &#96;-VarDecl 0x7fa1439f5708 &lt;col:5, col:21&gt; col:9 c &#39;int&#39; cinit</span><br><span class="line">|       &#96;-BinaryOperator 0x7fa142167c48 &lt;col:13, col:21&gt; &#39;int&#39; &#39;-&#39;</span><br><span class="line">|         |-BinaryOperator 0x7fa142167c00 &lt;col:13, col:17&gt; &#39;int&#39; &#39;+&#39;</span><br><span class="line">|         | |-ImplicitCastExpr 0x7fa1439f57b8 &lt;col:13&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">|         | | &#96;-DeclRefExpr 0x7fa1439f5768 &lt;col:13&gt; &#39;int&#39; lvalue ParmVar 0x7fa1439f54b0 &#39;a&#39; &#39;int&#39;</span><br><span class="line">|         | &#96;-ImplicitCastExpr 0x7fa1439f57d0 &lt;col:17&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">|         |   &#96;-DeclRefExpr 0x7fa1439f5790 &lt;col:17&gt; &#39;int&#39; lvalue ParmVar 0x7fa1439f5528 &#39;b&#39; &#39;int&#39;</span><br><span class="line">|         &#96;-IntegerLiteral 0x7fa142167c28 &lt;col:21&gt; &#39;int&#39; 3</span><br><span class="line"></span><br><span class="line">&#96;-&lt;undeserialized declarations&gt;</span><br></pre></td></tr></table></figure>

<p>在终端敲出的时候，终端很直观的帮我们用颜色区分。我们可以用图形显示如下：</p>
<img src="/YingYingMonstre.github.io/2021/12/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLLVM/test-AST.jpg" class="">

<center>test函数的语法树</center>


<h3 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h3><p>LLVM IR有3种表示形式（本质是等价的）</p>
<ul>
<li>text:便于阅读的文本格式，类似于汇编语言，拓展名.ll， $ clang -S -emit-llvm main.m</li>
<li>memory:内存格式</li>
<li>bitcode:二进制格式，拓展名.bc， $ clang -c -emit-llvm main.m</li>
</ul>
<p>我们以text形式编译查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define void @test(i32, i32) #2 &#123;</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  %5 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 %0, i32* %3, align 4</span><br><span class="line">  store i32 %1, i32* %4, align 4</span><br><span class="line">  %6 &#x3D; load i32, i32* %3, align 4</span><br><span class="line">  %7 &#x3D; load i32, i32* %4, align 4</span><br><span class="line">  %8 &#x3D; add nsw i32 %6, %7</span><br><span class="line">  %9 &#x3D; sub nsw i32 %8, 3</span><br><span class="line">  store i32 %9, i32* %5, align 4</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IR基本语法</strong><br>注释以分号 ; 开头<br>全局标识符以@开头，局部标识符以%开头<br>alloca，在当前函数栈帧中分配内存<br>i32，32bit，4个字节的意思<br>align，内存对齐<br>store，写入数据<br>load，读取数据<br>官方语法参考 <a href="https://links.jianshu.com/go?to=https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></p>
<h3 id="应用与实践"><a href="#应用与实践" class="headerlink" title="应用与实践"></a>应用与实践</h3><p>我们的开发都是基于源码开发，所以我们首先要进行源码下载和编译。<br><strong>源码下载</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载LLVM</span><br><span class="line">$ git clone https:&#x2F;&#x2F;git.llvm.org&#x2F;git&#x2F;llvm.git&#x2F;</span><br><span class="line"></span><br><span class="line">下载clang</span><br><span class="line">$ cd llvm&#x2F;tools</span><br><span class="line">$ git clone https:&#x2F;&#x2F;git.llvm.org&#x2F;git&#x2F;clang.git&#x2F;</span><br><span class="line"></span><br><span class="line">备注：clang是llvm的子项目，但是它们的源码是分开的，我们需要将clang放在llvm&#x2F;tools目录下。</span><br></pre></td></tr></table></figure>

<p><strong>源码编译</strong><br>这里我们在终端敲出的clang是xcode默认内置clang编译器，我们自己要进行LLVM开发的话，需要编译属于我们自己的clang编译器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先安装cmake和ninja(先安装brew，https:&#x2F;&#x2F;brew.sh&#x2F;)</span><br><span class="line">$ brew install cmake</span><br><span class="line">$ brew install ninja</span><br><span class="line"></span><br><span class="line">ninja如果安装失败，可以直接从github获取release版放入【&#x2F;usr&#x2F;local&#x2F;bin】中</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ninja-build&#x2F;ninja&#x2F;releases</span><br><span class="line"></span><br><span class="line">在LLVM源码同级目录下新建一个【llvm_build】目录(最终会在【llvm_build】目录下生成【build.ninja】</span><br><span class="line"></span><br><span class="line">$ cd llvm_build</span><br><span class="line">$ cmake -G Ninja ..&#x2F;llvm -DCMAKE_INSTALL_PREFIX&#x3D;LLVM的安装路径</span><br><span class="line"></span><br><span class="line">备注：生成build.ninja，就表示编译成功，-DCMAKE_INSTALL_PREFIX 表示编译好的东西放在指定的路径，-D表示参数。</span><br><span class="line"></span><br><span class="line">更多cmake相关选项，可以参考: https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;CMake.html</span><br></pre></td></tr></table></figure>

<p>接下来依次执行编译、安装指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ninja</span><br><span class="line">编译完毕后， 【llvm_build】目录大概 21.05 G（这个真的是好大啊）</span><br><span class="line">$ ninja install</span><br></pre></td></tr></table></figure>

<p>然后到这里我们的编译就完成了。</p>
<p>另一种方式是通过Xcode编译，生成Xcode项目再进行编译，但是速度很慢(可能需要1个多小时)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法如下：</span><br><span class="line"> 在llvm同级目录下新建一个【llvm_xcode】目录</span><br><span class="line">$ cd llvm_xcode</span><br><span class="line">$ cmake -G Xcode ..&#x2F;llvm</span><br></pre></td></tr></table></figure>

<p><strong>应用与实践的参考</strong></p>
<ul>
<li>libclang、libTooling<br>官方参考:<a href="https://links.jianshu.com/go?to=https://clang.llvm.org/docs/Tooling.html">https://clang.llvm.org/docs/Tooling.html</a><br>应用:语法树分析、语言转换等</li>
<li>Clang插件开发<br>官方参考<br>1、<a href="https://links.jianshu.com/go?to=https://clang.llvm.org/docs/ClangPlugins.html">https://clang.llvm.org/docs/ClangPlugins.html</a><br>2、<a href="https://links.jianshu.com/go?to=https://clang.llvm.org/docs/ExternalClangExamples.html">https://clang.llvm.org/docs/ExternalClangExamples.html</a><br>3、<a href="https://links.jianshu.com/go?to=https://clang.llvm.org/docs/RAVFrontendAction.html">https://clang.llvm.org/docs/RAVFrontendAction.html</a><br>应用:代码检查(命名规范、代码规范)等</li>
<li>Pass开发<br>官方参考:<a href="https://links.jianshu.com/go?to=https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a><br>应用:代码优化、代码混淆等</li>
<li>开发新的编程语言<br>1、 <a href="https://links.jianshu.com/go?to=https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a><br>2、<a href="https://links.jianshu.com/go?to=https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/</a></li>
</ul>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>搬运自<a href="https://www.jianshu.com/p/1367dad95445">深入浅出让你理解什么是LLVM</a></p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>XCTF-逆向基础篇</title>
    <url>/YingYingMonstre.github.io/2021/09/26/XCTF-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h2><p><strong>[工具]</strong></p>
<p>exeinfo pe, IDA </p>
<p><strong>[分析过程]</strong></p>
<p>0x01.查壳和程序的详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/insanity/1.png" alt="img"></p>
<p>发现这不是PE文件,是ELF文件，将程序在Linux环境下运行</p>
<p>0x02,查看程序的详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/insanity/2.png" alt="img"></p>
<p>发现是32位的程序</p>
<p>0x03.IDA </p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/insanity/3.png" alt="img"></p>
<p>F5查看伪函数</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/insanity/4.png" alt="img"></p>
<p>发现一个关键的字符串，&amp;strs,发现是取这个字符串输出，然后，跟进strs</p>
<p>(shift + f12 字符串窗口)</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/insanity/5.png" alt="img"></p>
<p>发现有一个明显的提示：This_is_a_flag</p>
<p>猜测9447{This_is_a_flag}是最后的falg</p>
<p>或者直接用记事本打开，仔细找也能找到。</p>
<h2 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h2><p><strong>[工具]</strong></p>
<p>在线python反编译</p>
<p><strong>[分析过程]</strong></p>
<p>0x01.下载附件</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/python-trade/1.png" alt="img"></p>
<blockquote>
<p>pyc文件是py文件编译后生成的字节码文件</p>
</blockquote>
<p>0x02.在线Python反编译</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/python-trade/2.png" alt="img"></p>
<p>这是生成的py文件</p>
<p>然后，对这个文件的运算逻辑进行逆向</p>
<p>0x03.写EXP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">correct = <span class="string">&quot;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&quot;</span></span><br><span class="line">s = base64.b64decode(correct)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    flag += <span class="built_in">chr</span>((i-<span class="number">16</span>) ^ <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/python-trade/3.png" alt="img"></p>
<p>先对字符串进行b64decode,然后，再进行xor运算得到最后的flag:nctf{d3c0mpil1n9_PyC}</p>
<p>0x04.运行脚本</p>
<p>nctf{d3c0mpil1n9_PyC}</p>
<h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p><strong>[工具]</strong></p>
<p>exeinfo pe, IDA </p>
<p><strong>[分析过程]</strong></p>
<p>参考</p>
<p>0x01.运行程序</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/re1/1.png" alt="img"></p>
<p>可以看到需要输入正确的flag</p>
<p>那么现在，我们需要判断程序是多少位的，有没有加壳</p>
<p>0x02.exeinfope查详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/re1/2.png" alt="img"></p>
<p>可以看到程序是32位的，是Microsoft Visual c++编译的，并且没有加壳</p>
<p>注：查壳工具还有PEID，EID，但是推荐EID或者exeinfope，因为，PEID查壳的时候有时候不准确</p>
<p>那么，我们可以用静态分析神器 IDA 打开，进一步分析了</p>
<p>0x03.</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/re1/3.png" alt="img"></p>
<p>然后，查找主函数main,可以看到右侧的是反汇编的汇编代码，这时候，我们可以直接分析汇编语言，但是，汇编语言看起来太多，费劲。这个时候就可以是有IDA是最强大的功能F5了，它能够直接将汇编代码生成C语言代码，虽然和这个程序的源码不完全一样，但是逻辑关系是一样的</p>
<p>F5查看伪代码</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/re1/4.png" alt="img"></p>
<p>这是整个main函数的运算逻辑</p>
<p>可以看到一个关键的字符串，print(aFlag)，那么证明这就是输入正确flag，然后，会输出aFlag证明你的flag正确，然后，继续往上分析，可以看到v3的值，是由strcmp()决定的，比较v5和输入的字符串，如果一样就会进入后面的if判断，所以,我们继续往上分析，看看哪里又涉及v5，可以看到开头的_mm_storeu_si128(），对其进行分析发现它类似于memset(),将xmmword_413E34的值赋值给v5，所以，我们可以得到正确的flag应该在xmmword_413E34中，然后，我们双击413E34进行跟进</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/re1/5.png" alt="img"></p>
<p>可以看到一堆十六进制的数</p>
<p>这时，我们使用IDA的另一个功能 R ，能够将十六进制的数转换为字符串。</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/re1/6.png" alt="img"></p>
<p>这就是我们最后的flag了</p>
<p>注：这里要跟大家普及一个知识了，及大端与小端</p>
<p>假设一个十六进制数0x12345678</p>
<p>大端的存储方式是：12,34,56,78，然后读取的时候也是从前往后读</p>
<p>小端的存储方式是：78,56,34,12，然后读取的时候是从后往前读取</p>
<p>所以，最后的flag应该是：DUTCTF{We1c0met0DUTCTF}</p>
<p>0x04.运行程序输入正确的flag</p>
<p>方法二：记事本打开，也能找到。</p>
<p>方法三：OD–》插件–》中文搜索引擎–》ASCII也能搜到。</p>
<h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>我的做法（暴力破解）：先用exeinfo pe查壳，发现是32位未加壳。用OD打开，用插件里的中文搜索ASCII，能找到done flag is的字符串。然后找到关键CALL（00B301BB和00B30359），修改跳转（从%d那里直接改为CALL xxxx跳到done那里）。运行到那里之后就可以得到flag了。</p>
<p>直接玩游戏：从1输到8。</p>
<p>爆破方法二：找到F5后伪代码最后那部分判断的代码（空格切换到图形视图，对着最后的那部分再空格切换回来），patch修改，正好有8个JNZ，改5个为jz，然后Edit–》Patch program–》Apply patches to input file，点OK，再回去运行就可以得到了。</p>
<p>IDA分析代码逻辑：先是判断是输入的是否是1-8，然后进入后面的if判断然后进行循环，这个时候应该就是程序的亮暗的显示，然后，如果byte_532E28每一位都是1，那么，就会进入sub_457AB4,然后我们猜测这里应该就是最后的flag的地方。然后跟进 sub_457AB4。（注：这里说明一下，如果IDA不能正确的获得自定义函数的名字，那么IDA会用sub__加上自定义函数的起始地址来定义函数的名字）</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/game/8.png" alt="img"></p>
<p>这里只截取了后面的部分，发现函数进行了两次xor运算，xor的逆运算也是xor，那么我们就可以根据这个运算来写脚本得到最后的flag。</p>
<p>这里看到v2和v59这就证明了这是两个数组的运算，所以我们应该将上面的字符串分成两个数组，分别从v2和v59开始</p>
<p>0x05.写EXP</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/game/9.png" alt="img"></p>
<p>这里先是通过循环，将a和b数组的值进行xor运算，然后再将数组a的值与0x13xor运算</p>
<p>chr()：是将十六进制转换为字符串</p>
<p>0x05.运行脚本</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/game/10.png" alt="img"></p>
<p>得到最后的flag: zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t}。</p>
<p>广度优先搜索法：未证。</p>
<h2 id="Hello，CTF"><a href="#Hello，CTF" class="headerlink" title="Hello，CTF"></a>Hello，CTF</h2><p>查壳，32位、无壳。</p>
<p>IDA从main开始分析，F5查看伪代码。首先，可以看到先是将字符串复制到v13的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcpy(&amp;v13, &quot;437261636b4d654a757374466f7246756e&quot;);</span><br></pre></td></tr></table></figure>

<p>然后，后面对输入进行了判断，输入的字符串不能大于17接着，将字符串以十六进制输出，然后，再将得到的十六进制字符添加到v10最后，进行比较，看输入的字符串是否和v10的字符串相等，如果相等，则得到真确的flag。最后将字符串转换为十六进制。</p>
<h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h2><p>代码审计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first = <span class="number">0xcafe</span></span><br><span class="line">flag = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">len</span>(<span class="string">&quot;h4cky0u&quot;</span>) - <span class="number">1615810207</span></span><br></pre></td></tr></table></figure>

<p>关键在于second的取值。观察代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里想到要get it就要将if里的逻辑取反，即second % 5 != 3 &amp;&amp; second % 17 == 8。</p>
<p>故(second % 17) * 11=8*11=88。得到flag=12648430–化为16进制–》c0ffee。</p>
<h2 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple_unpack"></a>simple_unpack</h2><p><strong>[工具]</strong></p>
<p>exeinfo pe, IDA, upx </p>
<p><strong>[分析过程]</strong></p>
<p>0x01.查壳和程序的详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple-unpack/1.png" alt="img"></p>
<p>发现有upx壳。</p>
<p>注：windows下的文件是PE文件，Linux/Unix下的文件是ELF文件</p>
<p>0x02.UPX 脱壳</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple-unpack/2.png" alt="img"></p>
<p>upx -d 即可对upx壳进行脱壳</p>
<p>0x03.载入IDA</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple-unpack/3.png" alt="img"></p>
<p>还是从main函数开始分析，结果我们再右侧发现了意外惊喜</p>
<p>运行程序，输入我们看到的flag:flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny}</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/simple-unpack/4.png" alt="img"></p>
<h2 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h2><p><strong>[工具]</strong></p>
<p>exeinfo pe, IDA </p>
<p><strong>[分析过程]</strong></p>
<p>0x01.查壳和查看程序的详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/logmein/1.png" alt="img"></p>
<p>发现程序是一个ELF文件，将其放入Linux环境中进行分析</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/logmein/2.png" alt="img"></p>
<p>发现程序是64位的，使用静态分析工具IDA进行分析</p>
<p>0x02.IDA</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/logmein/3.png" alt="img"></p>
<p>从main函数开始分析，使用F5查看伪代码</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/logmein/4.png" alt="img"></p>
<p>发现main函数的整个运算逻辑</p>
<p>先是，将指定字符串复制到v8</p>
<p>s是用户输入的字符串，先进行比较长度，如果长度比v8小，则进入sub_4007c0函数</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/logmein/5.png" alt="img"></p>
<p>可以看出输出字符串Incorrect password,然后，退出</p>
<p>如果长度大于或等与v8则进入下面的循环</p>
<p>看到判断如果输入的字符串和经过运算后的后字符串不等，则进入sub_4007c0,输出Incorrect password,</p>
<p>如果想得，则进入sub_4007f0函数</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/logmein/6.png" alt="img"></p>
<p>证明输入的字符串就是flag</p>
<p>接下来写脚本</p>
<p>0x03.Write EXP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v7 &#x3D; &quot;harambe&quot;</span><br><span class="line">v6 &#x3D; 7</span><br><span class="line">v8 &#x3D; &quot;:\&quot;AL_RT^L*.?+6&#x2F;46&quot;</span><br><span class="line">flag &#x3D; &quot;&quot;</span><br><span class="line">for i in range(0, len(v8)):</span><br><span class="line">    flag +&#x3D; chr(ord((v7[i % 7])) ^ ord(v8[i]))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>由于程序是小段的存储方式，所以，ebmarah就得变成harambe（C语言数据在内存中是小端存储，一开始v7是一个数据，so）</p>
<p>ord():是将字符串转换为ascii格式，为了方便运算</p>
<p>chr():是将ascii转换为字符串</p>
<p>运行脚本得到最后的flag:RC3-2016-XORISGUD</p>
<p>（直接用C语言更方便些）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define BYTE unsigned char</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	int v6 &#x3D; 7;</span><br><span class="line">	__int64 v7 &#x3D; 28537194573619560LL;</span><br><span class="line">	char v8[18] &#x3D; &quot;:\&quot;AL_RT^L*.?+6&#x2F;46&quot;;</span><br><span class="line">	char s[18] &#x3D; &quot;&quot;;</span><br><span class="line">	for ( i &#x3D; 0; i &lt; strlen(v8); ++i ) &#123;</span><br><span class="line">		s[i] +&#x3D; (char)(*((BYTE*)&amp;v7 + i % v6) ^ v8[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%s\n&quot;,s);</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h2><p><strong>[工具]</strong></p>
<p>exeinfo pe, IDA, GDB</p>
<p><strong>[分析过程]</strong></p>
<p>0x01.查壳和查看程序的详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/1.png" alt="img"></p>
<p>说明程序是ELF文件，32位</p>
<p>0x02.使用静态分析工具IDA进行分析</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/2.png" alt="img"></p>
<p>然后对main函数使用F5查看伪代码</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/3.png" alt="img"></p>
<p>然后，对每个函数进行跟进，最后发现authenricate(),符合获得flag的函数，对其进行跟进</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/4.png" alt="img"></p>
<p>然后我们发现一个特殊的函数decrypt,根据字面的意思是加密，那么我们可以大概的猜测是一个对dword_8048A90所对应的字符串进行加密，</p>
<p>加密得到的就应该是我们需要的flag，后面的判断应该就是将字符串输出。</p>
<p>这里我们有两种思维方式:</p>
<p>第一种就是跟进decrypt然后分析它的运算逻辑，然后，自己写脚本，得到最后的flag</p>
<p>第二种就涉及逆向的另一种调试方式，及动态调试，这里我就用动态调试了，之前的一直是静态调试</p>
<p>0x03.GDB动态调试</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/5.png" alt="img"></p>
<p>gdb ./no_strings_attached 将文件加载到GDB中</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/6.png" alt="img"></p>
<p>既然是动态调试，那么如果让它一直不停，那我不就相当于运行了嘛，所以，我们就需要下断点，断点就是让程序运行到断点处就停止</p>
<p>之前通过IDA，我们知道关键函数是decrypt,所以我们把断点设置在decrypt处，b在GDB中就是下断点的意思，及在decrypt处下断点</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/7.png" alt="img"></p>
<p>r就是运行的意思，这里运行到了我们之前下的断点处，停止。</p>
<p>我们要的是经过decrypt函数，生成的字符串，所以我们这里就需要运行一步，GDB中用n来表示运行一步</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/8.png" alt="img"></p>
<p>然后我们就需要去查看内存了，去查找最后生成的字符串</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/9.png" alt="img"></p>
<p>通过IDA生成的汇编指令，我们可以看出进过decrypt函数后，生成的字符串保存在EAX寄存器中，所以，我们在GDB就去查看eax寄存器的值</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/10.png" alt="img"></p>
<p>x:就是用来查看内存中数值的，后面的200代表查看多少个，wx代表是以word字节查看看，$eax代表的eax寄存器中的值</p>
<p>在这里我们看到0x00000000，这就证明这个字符串结束了，因为，在C中，代表字符串结尾的就是”\0”,那么前面的就是经过decrypt函数生成的falg</p>
<p>那我们就需要将这些转换为字符串的形式</p>
<p>0x04.Write EXP</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/11.png" alt="img"></p>
<p>首先将寄存器中的值提取出来，然后利用Python的decode函数，通过”hex”的方式转化为字符串，然后输出</p>
<p>0x05.运行脚本</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/no-strings-attached/12.png" alt="img"></p>
<p>得到最后的flag: 9447{you_are_an_international_mystery}</p>
<p>IDA分析就分析它的decrypt函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; [0x3a, 0x36, 0x37, 0x3b, 0x80, 0x7a, 0x71, 0x78,</span><br><span class="line">     0x63, 0x66, 0x73, 0x67, 0x62, 0x65, 0x73, 0x60,</span><br><span class="line">     0x6b, 0x71, 0x78, 0x6a, 0x73, 0x70, 0x64, 0x78,</span><br><span class="line">     0x6e, 0x70, 0x70, 0x64, 0x70, 0x64, 0x6e, 0x7b,</span><br><span class="line">     0x76, 0x78, 0x6a, 0x73, 0x7b, 0x80]</span><br><span class="line">v6 &#x3D; len(s)</span><br><span class="line">a2 &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">v7 &#x3D; len(a2)</span><br><span class="line">v2 &#x3D; v6</span><br><span class="line">dest &#x3D; s</span><br><span class="line">v4 &#x3D; 0</span><br><span class="line">while v4 &lt; v6:</span><br><span class="line">        dest[v4] -&#x3D; a2[v4 % 5]</span><br><span class="line">        v4 +&#x3D; 1</span><br><span class="line"></span><br><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line">for j in dest:</span><br><span class="line">    flag +&#x3D; chr(j)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>



<h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2><p><strong>[工具]</strong></p>
<p>exeinfo pe, IDA, GDB  </p>
<p><strong>[分析过程]</strong></p>
<p>0x01.查壳和程序的详细信息</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/1.png" alt="img"></p>
<p>可以看出这是一个ELF文件，64位</p>
<p>0x02.IDA</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/2.png" alt="img"></p>
<p>对main函数进行F5查看伪代码</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/3.png" alt="img"></p>
<p>可以看到先判断v5是否大于s存储字符串的长度，然后通过运算，最后将得到的flag写入文件。</p>
<p>但是有意思的地方在flag.txt文件所在的位置是/tmp目录，这个目录是Linux下的临时文件夹，程序运行完，生成flag的txt文件被清理了，所以我们找不到文件</p>
<p>我们这时候通过IDA查看汇编代码，按空格键可以生成所有的汇编文件</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/4.png" alt="img"></p>
<p>然后我们向下追踪，追踪到for循环的位置，因为，flag是在这里存入文件的，所以，我们可以在内存中找到正要存储的字符串</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/5.png" alt="img"></p>
<p>我们将鼠标指向strlen(),在下面可以看到汇编所在的地址，然后我们根据大概的地址去看汇编代码</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/6.png" alt="img"></p>
<p>可以看到这是调用strlen()函数的汇编指令</p>
<p>我们通过上一个图片，可以知道经过for()的判断条件后，还要进行一步fseek函数，所以，根据汇编代码，可以确定jnb loc_4008B5就是fseek()函数，那么，mov eax,[rbp+var_3C]肯定就是最后要得到的flag了</p>
<p>0x04.GDB</p>
<p>这里我们用linux下的动态调试工具gdb进行动态调试，这里介绍一下，对gdb进行强化的两个工具peda和pwndbg，这两个工具可以强化视觉效果，可以更加清楚的显示堆栈，内存，寄存机的情况</p>
<p>先加载程序</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/7.png" alt="img"></p>
<p>然后，用b 下断点</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/8.png" alt="img"></p>
<p>然后，运行 R</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/getit/9.png" alt="img"></p>
<p>这里我们可以看出，程序停止在0x400832的位置，然后，要被移动的字符串在RDX的位置</p>
<p>注：</p>
<p>这里介绍一下一下RDX，RDX存的是i/0指针，0x6010e0,这个位置存的字符串是最后的flag:SharifCTF{b70c59275fcfa8aebf2d5911223c6589}</p>
<p>以为这里涉及的是程序读写函数，所以涉及的就是i/o指针</p>
<p>所以我们能得到最后的flag: SharifCTF{b70c59275fcfa8aebf2d5911223c6589}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;c61b68366edeb7bdce3c6820314b7498&quot;</span><br><span class="line">v3 &#x3D; 0</span><br><span class="line">v5 &#x3D; 0</span><br><span class="line">t &#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">while v5 &lt; len(s):</span><br><span class="line">    if v5 &amp; 1:</span><br><span class="line">        v3 &#x3D; 1</span><br><span class="line">    else:</span><br><span class="line">        v3 &#x3D; -1</span><br><span class="line">    t +&#x3D; chr(ord(s[v5]) + v3)</span><br><span class="line">    v5 +&#x3D; 1</span><br><span class="line"></span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>



<h2 id="csaw2013reversing2"><a href="#csaw2013reversing2" class="headerlink" title="csaw2013reversing2"></a>csaw2013reversing2</h2><p><a href="https://blog.csdn.net/weixin_43784056/article/details/103655968">XCTF-csaw2013reversing2_臭nana的博客-CSDN博客</a></p>
<p>默认if条件不成立，跳过了sub_401000的解码，输出一堆乱码。</p>
<h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><p>迷宫问题</p>
<p><img src="https://www.pianshen.com/images/271/7d91ebf895b8ed648ed3ab80de463137.JPEG" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Boofuzz源码分析</title>
    <url>/YingYingMonstre.github.io/2022/03/22/Boofuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Boofuzz样例"><a href="#Boofuzz样例" class="headerlink" title="Boofuzz样例"></a>Boofuzz样例</h3><p>以一个TFTP Fuzzer为例，大概看一下Boofuzz的用法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boofuzz <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    session = Session(sleep_time=<span class="number">1</span>,</span><br><span class="line">                      target=Target(connection=SocketConnection(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">69</span>,proto=<span class="string">&quot;udp&quot;</span>)))</span><br><span class="line">    s_initialize(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">    s_static(<span class="string">&quot;\\x00\\x02&quot;</span>)</span><br><span class="line">    s_string(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    s_static(<span class="string">&quot;\\x00&quot;</span>)</span><br><span class="line">    s_static(<span class="string">&quot;netascii&quot;</span>)</span><br><span class="line">    s_static(<span class="string">&quot;\\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">    session.connect(s_get(<span class="string">&#x27;write&#x27;</span>))</span><br><span class="line">    session.fuzz()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在源码中可以看到<code>SocketConnection</code>会在未来版本中移除，现在应该使用<code>BaseSocketConnection</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">warnings.warn(</span><br><span class="line">        <span class="string">&quot;SocketConnection is deprecated and will be removed in a future version of Boofuzz. &quot;</span></span><br><span class="line">        <span class="string">&quot;Use the classes derived from BaseSocketConnection instead.&quot;</span>,</span><br><span class="line">        FutureWarning,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>Fuzzer的创建包含三层，Session -&gt; Target -&gt; Connection</p>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>顾名思义，Connection对象是网络连接的代表，Boofuzz支持各种基于socket的连接，从源码部分就可以看到，常用的还是TCP和UDP，这里还支持网络协议栈中2层和3层的原生Socket。</p>
<img src="Boofuzz源码分析/connection.png" alt="/External Library" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SocketConnection</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    host,</span></span></span><br><span class="line"><span class="function"><span class="params">    port=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    proto=<span class="string">&quot;tcp&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    bind=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    send_timeout=<span class="number">5.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    recv_timeout=<span class="number">5.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ethernet_proto=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    l2_dst=<span class="string">b&quot;\xFF&quot;</span> * <span class="number">6</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    udp_broadcast=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    server=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    sslcontext=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    server_hostname=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    warnings.warn(</span><br><span class="line">        <span class="string">&quot;SocketConnection is deprecated and will be removed in a future version of Boofuzz. &quot;</span></span><br><span class="line">        <span class="string">&quot;Use the classes derived from BaseSocketConnection instead.&quot;</span>,</span><br><span class="line">        FutureWarning,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> proto <span class="keyword">not</span> <span class="keyword">in</span> _PROTOCOLS:</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;INVALID PROTOCOL SPECIFIED: %s&quot;</span> % proto)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto <span class="keyword">in</span> _PROTOCOLS_PORT_REQUIRED <span class="keyword">and</span> port <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;__init__() argument port required for protocol &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(proto))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto == <span class="string">&quot;udp&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> udp_socket_connection.UDPSocketConnection(</span><br><span class="line">            host, port, send_timeout, recv_timeout, server, bind, udp_broadcast</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> proto == <span class="string">&quot;tcp&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> tcp_socket_connection.TCPSocketConnection(host, port, send_timeout, recv_timeout, server)</span><br><span class="line">    <span class="keyword">elif</span> proto == <span class="string">&quot;ssl&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> ssl_socket_connection.SSLSocketConnection(</span><br><span class="line">            host, port, send_timeout, recv_timeout, server, sslcontext, server_hostname</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> proto == <span class="string">&quot;raw-l2&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> raw_l2_socket_connection.RawL2SocketConnection(host, send_timeout, recv_timeout)</span><br><span class="line">    <span class="keyword">elif</span> proto == <span class="string">&quot;raw-l3&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> ethernet_proto <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ethernet_proto = raw_l3_socket_connection.ETH_P_IP</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> raw_l3_socket_connection.RawL3SocketConnection(host, send_timeout, recv_timeout, ethernet_proto, l2_dst)</span><br></pre></td></tr></table></figure>

<p>在<code>SocketConnection</code>函数中根据我们传入的proto参数来调用响应Connection类的构造函数。</p>
<p>以<code>TCPSocketConnection</code>为例,其继承自<code>BaseSocketConnection</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSocketConnection</span>(<span class="params">base_socket_connection.BaseSocketConnection</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;BaseSocketConnection implementation for use with TCP Sockets.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 0.2.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        host (str): Hostname or IP adress of target system.</span></span><br><span class="line"><span class="string">        port (int): Port of target service.</span></span><br><span class="line"><span class="string">        send_timeout (float): Seconds to wait for send before timing out. Default 5.0.</span></span><br><span class="line"><span class="string">        recv_timeout (float): Seconds to wait for recv before timing out. Default 5.0.</span></span><br><span class="line"><span class="string">        server (bool): Set to True to enable server side fuzzing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, port, send_timeout=<span class="number">5.0</span>, recv_timeout=<span class="number">5.0</span>, server=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(TCPSocketConnection, self).__init__(send_timeout, recv_timeout)</span><br><span class="line"></span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.server = server</span><br><span class="line">        self._serverSock = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><code>BaseSocketConnection</code>是一个继承了<code>itarget_connection.ITargetConnection</code>接口的抽象基类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSocketConnection</span>(<span class="params">with_metaclass(<span class="params">abc.ABCMeta, itarget_connection.ITargetConnection</span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This class serves as a base for a number of Connections over sockets.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 0.2.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        send_timeout (float): Seconds to wait for send before timing out. Default 5.0.</span></span><br><span class="line"><span class="string">        recv_timeout (float): Seconds to wait for recv before timing out. Default 5.0.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, send_timeout, recv_timeout</span>):</span></span><br><span class="line">        self._send_timeout = send_timeout</span><br><span class="line">        self._recv_timeout = recv_timeout</span><br><span class="line"></span><br><span class="line">        self._sock = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Close connection to the target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._sock.close()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Opens connection to the target. Make sure to call close!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDTIMEO, _seconds_to_sockopt_format(self._send_timeout))</span><br><span class="line">        self._sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, _seconds_to_sockopt_format(self._recv_timeout))</span><br></pre></td></tr></table></figure>



<h4 id="python元类编程"><a href="#python元类编程" class="headerlink" title="python元类编程"></a>python元类编程</h4><p>抽象类和接口都是面向对象里面的概念，抽象类是指一类<strong>不可直接实例化，只可被继承</strong>的类，接口则定义了继承接口的类必须实现的方法。python是没有这两个概念相关的关键字的，在python中，抽象类是以抽象基类的方式实现的(Abstract Base Classes, ABC)。</p>
<p>ABC中提供了<code>@abstractmethod</code>装饰器来指定抽象方法,下面代码中定义了一个抽象类C，并且定义了三个抽象方法，D类则是继承抽象类C然后实现了他的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span>(<span class="params">self</span>):</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clsa</span>(<span class="params">cls</span>):</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stca</span>():</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">C</span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;property: a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clsa</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;classmethod clsa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stca</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;staticmethod stca&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">d = D()</span><br><span class="line">d.a</span><br><span class="line"><span class="comment"># property: a</span></span><br><span class="line">d.clsa()</span><br><span class="line"><span class="comment"># classmethod clsa</span></span><br><span class="line">d.stca()</span><br><span class="line"><span class="comment"># staticmethod stca</span></span><br></pre></td></tr></table></figure>

<p>这里<code>BaseSocketConnection</code>的定义中用到了<code>with_metaclass</code>来创建这个类。</p>
<p><a href="https://stackoverflow.com/questions/18513821/python-metaclass-understanding-the-with-metaclass">Python Metaclass : Understanding the ‘with_metaclass()’ - Stack Overflow</a></p>
<p>这里引入<code>with_metaclass</code>是为了兼容python2和python3，在我的python3.8上<code>with_metaclass</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_metaclass</span>(<span class="params">meta, *bases</span>):</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">metaclass</span>(<span class="params">meta</span>):</span></span><br><span class="line">        __call__ = <span class="built_in">type</span>.__call__</span><br><span class="line">        __init__ = <span class="built_in">type</span>.__init__</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, this_bases, d</span>):</span></span><br><span class="line">            <span class="keyword">if</span> this_bases <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, (), d)</span><br><span class="line">            <span class="keyword">return</span> meta(name, bases, d)</span><br><span class="line">    <span class="keyword">return</span> metaclass(<span class="string">&#x27;temporary_class&#x27;</span>, <span class="literal">None</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>根据<code>BaseSocketConnection</code>传入的参数，这里meta是<code>ABCmeta</code>，bases是<code>ITargetConnection</code>，这里是定义了一个临时元类metaclass继承自ABCmeta，并重写了其new方法，这样下面return时，就会依次调用其new和init方法来新建一个对象，而元类创建的是一个类，因此结果是一个基类为bases的抽象类，然后BaseSocketConnection就继承自它。这里具体的调试过程没搞明白。</p>
<p>总之这里BaseSocketConnection继承了ITargetConnection的接口，并且定义了一些基本方法，如open、send、recv、close以及关于延时的变量等。</p>
<h4 id="TCPSocketConnection"><a href="#TCPSocketConnection" class="headerlink" title="TCPSocketConnection"></a>TCPSocketConnection</h4><p>具体的TCPSocket的实现。</p>
<h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">    self._open_socket()</span><br><span class="line">    self._connect_socket()</span><br></pre></td></tr></table></figure>



<h5 id="open-socket函数"><a href="#open-socket函数" class="headerlink" title="open_socket函数"></a>open_socket函数</h5><p>就是创建一个socket。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_open_socket</span>(<span class="params">self</span>):</span></span><br><span class="line">    self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call superclass to set timeout sockopt</span></span><br><span class="line">    <span class="built_in">super</span>(TCPSocketConnection, self).<span class="built_in">open</span>()</span><br></pre></td></tr></table></figure>



<h5 id="connect-socket函数"><a href="#connect-socket函数" class="headerlink" title="connect_socket函数"></a>connect_socket函数</h5><p>这里可以看到boofuzz支持server被连接的模式，server只会接受一个连接。如果是多连接的场景，需要自己修改对应逻辑，主动连接同理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_connect_socket</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment">#server模式</span></span><br><span class="line">    <span class="keyword">if</span> self.server:</span><br><span class="line">        self._sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._sock.bind((self.host, self.port))</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.errno == errno.EADDRINUSE:</span><br><span class="line">                <span class="keyword">raise</span> exception.BoofuzzOutOfAvailableSockets()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        self._serverSock = self._sock</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#只会接受一个连接</span></span><br><span class="line">            self._serverSock.listen(<span class="number">1</span>)</span><br><span class="line">            self._sock, addr = self._serverSock.accept()</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># When connection timeout expires, tear down the server socket so we can re-open it again after</span></span><br><span class="line">            <span class="comment"># restarting the target.</span></span><br><span class="line">            self.close()</span><br><span class="line">            <span class="keyword">if</span> e.errno <span class="keyword">in</span> [errno.EAGAIN]:</span><br><span class="line">                <span class="keyword">raise</span> exception.BoofuzzTargetConnectionFailedError(<span class="built_in">str</span>(e))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">    <span class="comment">#主动连接</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._sock.connect((self.host, self.port))</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.errno == errno.EADDRINUSE:</span><br><span class="line">                <span class="keyword">raise</span> exception.BoofuzzOutOfAvailableSockets()</span><br><span class="line">            <span class="keyword">elif</span> e.errno <span class="keyword">in</span> [errno.ECONNREFUSED, errno.EINPROGRESS, errno.ETIMEDOUT]:</span><br><span class="line">                <span class="keyword">raise</span> exception.BoofuzzTargetConnectionFailedError(<span class="built_in">str</span>(e))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>



<h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p>向目标发送数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        num_sent = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num_sent = self._sock.send(data)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.errno == errno.ECONNABORTED:</span><br><span class="line">                raise_(</span><br><span class="line">                    exception.BoofuzzTargetConnectionAborted(socket_errno=e.errno, socket_errmsg=e.strerror),</span><br><span class="line">                    <span class="literal">None</span>,</span><br><span class="line">                    sys.exc_info()[<span class="number">2</span>],</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">elif</span> e.errno <span class="keyword">in</span> [errno.ECONNRESET, errno.ENETRESET, errno.ETIMEDOUT, errno.EPIPE]:</span><br><span class="line">                raise_(exception.BoofuzzTargetConnectionReset(), <span class="literal">None</span>, sys.exc_info()[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_sent</span><br></pre></td></tr></table></figure>



<h5 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h5><p>这里可以设定最大接受字节数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self, max_bytes</span>):</span></span><br><span class="line">        data = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = self._sock.recv(max_bytes)</span><br><span class="line">        <span class="keyword">except</span> socket.timeout:</span><br><span class="line">            data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.errno == errno.ECONNABORTED:</span><br><span class="line">                raise_(</span><br><span class="line">                    exception.BoofuzzTargetConnectionAborted(socket_errno=e.errno, socket_errmsg=e.strerror),</span><br><span class="line">                    <span class="literal">None</span>,</span><br><span class="line">                    sys.exc_info()[<span class="number">2</span>],</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">elif</span> (e.errno == errno.ECONNRESET) <span class="keyword">or</span> (e.errno == errno.ENETRESET) <span class="keyword">or</span> (e.errno == errno.ETIMEDOUT):</span><br><span class="line">                raise_(exception.BoofuzzTargetConnectionReset(), <span class="literal">None</span>, sys.exc_info()[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">elif</span> e.errno == errno.EWOULDBLOCK:  <span class="comment"># timeout condition if using SO_RCVTIMEO or SO_SNDTIMEO</span></span><br><span class="line">                data = <span class="string">b&quot;&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>可以看出Connection这层就已经实现了连接的建立以及数据的收发相关的功能。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Target descriptor container.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Takes an ITargetConnection and wraps send/recv with appropriate</span></span><br><span class="line"><span class="string">    FuzzDataLogger calls.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>Target注释部分也说了，Target对象主要是在<code>Connection</code>的接口上wrap上log。可以看到Target的send函数，除了加的repeater功能，基本上就是添加了log。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Opens connection to the target. Make sure to call close!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._fuzz_data_logger.log_info(<span class="string">&quot;Opening target connection (&#123;0&#125;)...&quot;</span>.<span class="built_in">format</span>(self._target_connection.info))</span><br><span class="line">    self._target_connection.<span class="built_in">open</span>()</span><br><span class="line">    self._fuzz_data_logger.log_info(<span class="string">&quot;Connection opened.&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Send data to the target. Only valid after calling open!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data: Data to send.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_sent = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> self._fuzz_data_logger <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        repeat = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.repeater <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            repeat = <span class="string">&quot;, &quot;</span> + self.repeater.log_message()</span><br><span class="line"></span><br><span class="line">        self._fuzz_data_logger.log_info(<span class="string">&quot;Sending &#123;0&#125; bytes&#123;1&#125;...&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(data), repeat))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.repeater <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.repeater.start()</span><br><span class="line">        <span class="keyword">while</span> self.repeater.repeat():</span><br><span class="line">            num_sent = self._target_connection.send(data=data)</span><br><span class="line">        self.repeater.reset()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        num_sent = self._target_connection.send(data=data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._fuzz_data_logger <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._fuzz_data_logger.log_send(data[:num_sent])</span><br></pre></td></tr></table></figure>

<p>另外Target中还有一些Monitor的初始化工作，后面再说，Target中提供了设置Logger的接口函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_fuzz_data_logger</span>(<span class="params">self, fuzz_data_logger</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Set this object&#x27;s fuzz data logger -- for sent and received fuzz data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param fuzz_data_logger: New logger.</span></span><br><span class="line"><span class="string">    :type fuzz_data_logger: ifuzz_logger.IFuzzLogger</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._fuzz_data_logger = fuzz_data_logger</span><br></pre></td></tr></table></figure>

<p>在session中会调用这个函数来添加logger，默认是<code>FuzzLoggerText</code>。</p>
<h3 id="Session-Logger部分"><a href="#Session-Logger部分" class="headerlink" title="Session Logger部分"></a>Session Logger部分</h3><p>Session对象可以看成fuzzer的后端对象，其参数基本上就是涉及到fuzz控制的各种粒度，其函数基本上就是fuzz过程了。fuzz过程后面再分析，这里先看下上面余留的logger部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span>(<span class="params">pgraph.Graph</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">args</span>):</span></span><br><span class="line">        <span class="keyword">if</span> fuzz_loggers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            fuzz_loggers = []</span><br><span class="line">            <span class="keyword">if</span> self.console_gui <span class="keyword">and</span> os.name != <span class="string">&quot;nt&quot;</span>:</span><br><span class="line">                fuzz_loggers.append(fuzz_logger_curses.FuzzLoggerCurses(web_port=self.web_port))</span><br><span class="line">                self._keep_web_open = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fuzz_loggers = [fuzz_logger_text.FuzzLoggerText()]</span><br></pre></td></tr></table></figure>

<p>如果<code>fuzz_loggers</code>没指定的话，这里就设置成<code>FuzzLoggerText</code>，而<code>FuzzLoggerText</code>默认会设置为标注输出，因此就形成了打印到终端，所以如果想输出到文件，就可以set自己new的FuzzLoggerText，并设置其file_handle为文件句柄。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuzzLoggerText</span>(<span class="params">ifuzz_logger_backend.IFuzzLoggerBackend</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_handle=sys.stdout, bytes_to_str=DEFAULT_HEX_TO_STR</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type file_handle: io.BinaryIO</span></span><br><span class="line"><span class="string">        :param file_handle: Open file handle for logging. Defaults to sys.stdout.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type bytes_to_str: function</span></span><br><span class="line"><span class="string">        :param bytes_to_str: Function that converts sent/received bytes data to string for logging.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._file_handle = file_handle</span><br><span class="line">        self._format_raw_bytes = bytes_to_str</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_print_log_msg</span>(<span class="params">self, msg_type, msg=<span class="literal">None</span>, data=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            helpers.format_log_msg(msg_type=msg_type, description=msg, data=data, indent_size=self.INDENT_SIZE),</span><br><span class="line">            file=self._file_handle,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>



<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>boofuzz是基于格式的，因此在开始fuzz前需要先定义目标数据格式。boofuzz有两种数据定义的方式：Static Protocol Definition(old) 和 Protocol Definition(new) 。这两种数据定义的方式只是接口不同，其内部存储的格式是类似的，而且每种基本都够用了，所以这里只分析下Static Protocol Definition。</p>
<p><a href="https://boofuzz.readthedocs.io/en/stable/user/static-protocol-definition.html">Static Protocol Definition — boofuzz 0.4.0 documentation</a></p>
<p><a href="https://boofuzz.readthedocs.io/en/stable/user/protocol-definition.html">Protocol Definition — boofuzz 0.4.0 documentation</a></p>
<p>数据分成三个层次，Requests是发出的message，Blocks来组成message，Primitives(原语)是组成block的元素(字节、字符串、数字、校验和等)。</p>
<h4 id="s-initialize"><a href="#s-initialize" class="headerlink" title="s_initialize"></a>s_initialize</h4><p><code>s_initialize</code>会创建一个request，我们需要提供一个name来标识这个request，新建的request会被加到<code>REQUESTS</code>中，并设置为当前操作的Request。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_initialize</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Initialize a new block request. All blocks / primitives generated after this call apply to the named request.</span></span><br><span class="line"><span class="string">    Use s_switch() to jump between factories.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :type  name: str</span></span><br><span class="line"><span class="string">    :param name: Name of request</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> blocks.REQUESTS:</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;blocks.REQUESTS ALREADY EXISTS: %s&quot;</span> % name)</span><br><span class="line">		<span class="comment">#REQUESTS是全局字典，这里向其添加个request</span></span><br><span class="line">    blocks.REQUESTS[name] = Request(name)</span><br><span class="line">    <span class="comment">#同时将新建的设置为当前操作的request</span></span><br><span class="line">    blocks.CURRENT = blocks.REQUESTS[name]</span><br></pre></td></tr></table></figure>



<h4 id="Session-init"><a href="#Session-init" class="headerlink" title="Session.init"></a>Session.init</h4><p>Session中创建根结点，用户可以指定一些initial requests：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对图初始化，新建一个root节点</span></span><br><span class="line"> self.root = pgraph.Node()</span><br><span class="line"> self.root.label = <span class="string">&quot;__ROOT_NODE__&quot;</span></span><br><span class="line"> self.root.name = self.root.label</span><br><span class="line"> self.last_recv = <span class="literal">None</span></span><br><span class="line"> self.last_send = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"> self.add_node(self.root)</span><br><span class="line">  <span class="comment">#把传进来的target加到target数组中</span></span><br><span class="line"> <span class="keyword">if</span> target <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">apply_options</span>(<span class="params">monitor</span>):</span></span><br><span class="line">         monitor.set_options(crash_filename=self._crash_filename)</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">     target.monitor_alive.append(apply_options)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>:</span><br><span class="line">         self.add_target(target)</span><br><span class="line">     <span class="keyword">except</span> exception.BoofuzzRpcError <span class="keyword">as</span> e:</span><br><span class="line">         self._fuzz_data_logger.log_error(<span class="built_in">str</span>(e))</span><br><span class="line">         <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>



<h4 id="s-get、s-switch"><a href="#s-get、s-switch" class="headerlink" title="s_get、s_switch"></a>s_get、s_switch</h4><p>网络协议一般是各种Request的状态转移图，Boofuzz也支持建立这种图。我们可以再次调用s_initialize来创建一个新的Request，通过s_get可以在不同的Request直接切换，从而改变当前操作的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_get</span>(<span class="params">name=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">        <span class="keyword">return</span> blocks.CURRENT</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ensure this gotten request is the new current.</span></span><br><span class="line">    s_switch(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> blocks.REQUESTS:</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;blocks.REQUESTS NOT FOUND: %s&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blocks.REQUESTS[name]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_switch</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Change the current request to the one specified by &quot;name&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :type  name: str</span></span><br><span class="line"><span class="string">    :param name: Name of request</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> blocks.REQUESTS:</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;blocks.REQUESTS NOT FOUND: %s&quot;</span> % name)</span><br><span class="line">		<span class="comment">#将name的Request设置为CURRENT</span></span><br><span class="line">    blocks.CURRENT = blocks.REQUESTS[name]</span><br></pre></td></tr></table></figure>



<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>connect是连边，即在两个Node(Request)上连边。只填一个参数的话，就是默认把提供的参数node连到root上，node就是Request对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, src, dst=<span class="literal">None</span>, callback=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="comment"># if only a source was provided, then make it the destination and set the source to the root node.</span></span><br><span class="line">        <span class="keyword">if</span> dst <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment">#dst不指定就是从 root连接到src</span></span><br><span class="line">            dst = src</span><br><span class="line">            src = self.root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if source or destination is a name, resolve the actual node.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(src, six.string_types):</span><br><span class="line">            src = self.find_node(<span class="string">&quot;name&quot;</span>, src)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(dst, six.string_types):</span><br><span class="line">            dst = self.find_node(<span class="string">&quot;name&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if source or destination is not in the graph, add it.</span></span><br><span class="line">        <span class="keyword">if</span> src != self.root <span class="keyword">and</span> self.find_node(<span class="string">&quot;name&quot;</span>, src.name) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.add_node(src)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.find_node(<span class="string">&quot;name&quot;</span>, dst.name) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.add_node(dst)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create an edge between the two nodes and add it to the graph.</span></span><br><span class="line">        edge = Connection(src.<span class="built_in">id</span>, dst.<span class="built_in">id</span>, callback)  <span class="comment">#建边</span></span><br><span class="line">        self.add_edge(edge)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> edge</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a pgraph node to the graph. We overload this routine to automatically generate and assign an ID whenever a</span></span><br><span class="line"><span class="string">        node is added.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            node (pgraph.Node): Node to add to session graph</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        node.number = <span class="built_in">len</span>(self.nodes)</span><br><span class="line">        node.<span class="built_in">id</span> = <span class="built_in">len</span>(self.nodes)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">id</span> <span class="keyword">not</span> <span class="keyword">in</span> self.nodes:</span><br><span class="line">            self.nodes[node.<span class="built_in">id</span>] = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>

<p>这个 Connection 就是继承自最朴素的Edge(边)，只不过其提供了一个callback参数，这个会在状态转移的时候调用，因此可以添加一些自定义的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span>(<span class="params">pgraph.Edge</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, src, dst, callback=<span class="literal">None</span></span>):</span></span><br><span class="line">		    <span class="built_in">super</span>(Connection, self).__init__(src, dst)</span><br><span class="line"></span><br><span class="line">        self.callback = callback</span><br></pre></td></tr></table></figure>

<p>状态图案例：</p>
<img src="/YingYingMonstre.github.io/2022/03/22/Boofuzz%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/connect_graph.png" class="">

<p>创建完Request之后，接下来就是向里面添加Primitives，根据数据类型划分出多个添加函数，首先看string类型的函数s_string。</p>
<h4 id="s-string"><a href="#s-string" class="headerlink" title="s_string"></a>s_string</h4><p>函数中新建String对象后，通过Request的push函数填充到request中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_string</span>(<span class="params">value=<span class="string">&quot;&quot;</span>, size=<span class="literal">None</span>, padding=<span class="string">b&quot;\x00&quot;</span>, encoding=<span class="string">&quot;ascii&quot;</span>, fuzzable=<span class="literal">True</span>, max_len=<span class="literal">None</span>, name=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># support old interface where default was -1 instead of None</span></span><br><span class="line">    <span class="keyword">if</span> size == -<span class="number">1</span>:</span><br><span class="line">        size = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> max_len == -<span class="number">1</span>:</span><br><span class="line">        max_len = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    blocks.CURRENT.push(</span><br><span class="line">        String(</span><br><span class="line">            name=name,</span><br><span class="line">            default_value=value,</span><br><span class="line">            size=size,</span><br><span class="line">            padding=padding,</span><br><span class="line">            encoding=encoding,</span><br><span class="line">            max_len=max_len,</span><br><span class="line">            fuzzable=fuzzable,</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>



<h4 id="Request-push"><a href="#Request-push" class="headerlink" title="Request.push"></a>Request.push</h4><p>1.首先给传进来的item也就是Primitive添加一些环境信息：</p>
<p> (1)context_path: 调用<code>_generate_context_path</code>产生的字符串，<code>_generate_context_path</code>是将<code>block_stack</code>中的字符串全部拼接在一起产生路径字符串，用于标记item的位置；</p>
<p> (2)设置item的request为当前request。</p>
<p>2.检查item的<code>qualified_name</code>是否重复，判断是否将item加入到names map中；</p>
<p>3.如果当前request还没有block，<code>block_stack</code>就为空，就将item插入到request的stack中；如果<code>block_stack</code>不为空，就相当于现在还在组建block，就把item插入到栈顶的block中；</p>
<p>4.如果item是block，会先把block插入到stack中，然后插入到<code>block_stack</code>中作为当前的<code>open_block</code>,接下来的primitive都会插入到该block里面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Push an item into the block structure. If no block is open, the item goes onto the request stack. otherwise,</span></span><br><span class="line"><span class="string">    the item goes onto the last open blocks stack.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    What this method does:</span></span><br><span class="line"><span class="string">    1. Sets context_path for each pushed FuzzableWrapper.</span></span><br><span class="line"><span class="string">    2. Sets request for each FuzzableWrapper</span></span><br><span class="line"><span class="string">    3. Checks for duplicate qualified_name items</span></span><br><span class="line"><span class="string">    4. Adds item to self.names map (based on qualified_name)</span></span><br><span class="line"><span class="string">    5. Adds the item to self.stack, or to the stack of the currently opened block.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Also: Manages block_stack, mostly an implementation detail to help static protocol definition</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @type item: BasePrimitive | Block | Request | Size | Repeat</span></span><br><span class="line"><span class="string">    @param item: Some primitive/block/request/etc.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    item.context_path = self._generate_context_path(self.block_stack)</span><br><span class="line">    item.request = self</span><br><span class="line">    <span class="comment"># ensure the name doesn&#x27;t already exist.</span></span><br><span class="line">    <span class="keyword">if</span> item.qualified_name <span class="keyword">in</span> <span class="built_in">list</span>(self.names):</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;BLOCK NAME ALREADY EXISTS: %s&quot;</span> % item.qualified_name)</span><br><span class="line"></span><br><span class="line">    self.names[item.qualified_name] = item</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if there are no open blocks, the item gets pushed onto the request stack.</span></span><br><span class="line">    <span class="comment"># otherwise, the pushed item goes onto the stack of the last opened block.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.block_stack:</span><br><span class="line">        self.stack.append(item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.block_stack[-<span class="number">1</span>].push(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add the opened block to the block stack.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, Block) <span class="keyword">or</span> <span class="built_in">isinstance</span>(item, Aligned):  <span class="comment"># TODO generic check here</span></span><br><span class="line">        self.block_stack.append(item)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_context_path</span>(<span class="params">self, block_stack</span>):</span></span><br><span class="line">    context_path = <span class="string">&quot;.&quot;</span>.join(x.name <span class="keyword">for</span> x <span class="keyword">in</span> block_stack)  <span class="comment"># TODO put in method</span></span><br><span class="line">    context_path = <span class="string">&quot;.&quot;</span>.join(<span class="built_in">filter</span>(<span class="literal">None</span>, (self.name, context_path)))</span><br><span class="line">    <span class="keyword">return</span> context_path</span><br></pre></td></tr></table></figure>



<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>根据doc，有两种插入block的方式：<code>startend</code>和<code>with</code>模式。</p>
<h5 id="startend方式"><a href="#startend方式" class="headerlink" title="startend方式"></a>startend方式</h5><p><code>s_block_start </code>初始化一个block，并将其push。</p>
<p><code>s_block_close </code>关闭这个block，说明数据已经填充完毕了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s_block_start(<span class="string">&quot;header&quot;</span>):</span><br><span class="line">    s_static(<span class="string">&quot;\x00\x01&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s_block_start(<span class="string">&quot;body&quot;</span>):</span><br><span class="line">        ...</span><br><span class="line">s_block_end()</span><br></pre></td></tr></table></figure>

<p><code>s_block_start</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_block_start</span>(<span class="params">name=<span class="literal">None</span>, *args, **kwargs</span>):</span></span><br><span class="line">    block = Block(name=name, *args, **kwargs)</span><br><span class="line">    blocks.CURRENT.push(block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block</span><br></pre></td></tr></table></figure>

<p><code>s_block_end</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_block_end</span>(<span class="params">name=<span class="literal">None</span></span>):</span></span><br><span class="line">    blocks.CURRENT.pop()</span><br></pre></td></tr></table></figure>



<h5 id="with方式"><a href="#with方式" class="headerlink" title="with方式"></a>with方式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> s_block(<span class="string">&quot;header&quot;</span>):</span><br><span class="line">    s_static(<span class="string">&quot;\x00\x01&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> s_block_start(<span class="string">&quot;body&quot;</span>):</span><br></pre></td></tr></table></figure>

<p>with方式能用是因为<code>s_block</code>中调用的是<code>s_block_start</code>插入block，但是返回的是个<code>ScopedBlock</code>对象，这个对象注册了<strong>exit</strong>方法。</p>
<p>当with范围结束时，就会调用<code>s_block_end</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_block</span>(<span class="params">name=<span class="literal">None</span>, group=<span class="literal">None</span>, encoder=<span class="literal">None</span>, dep=<span class="literal">None</span>, dep_value=<span class="literal">None</span>, dep_values=<span class="literal">None</span>, dep_compare=<span class="string">&quot;==&quot;</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ScopedBlock</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, block</span>):</span></span><br><span class="line">            self.block = block</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            Setup before entering the &quot;with&quot; statement body</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> self.block</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            Cleanup after executing the &quot;with&quot; statement body</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># Automagically close the block when exiting the &quot;with&quot; statement</span></span><br><span class="line">            s_block_end()</span><br><span class="line"></span><br><span class="line">    block = s_block_start(</span><br><span class="line">        name,</span><br><span class="line">        request=blocks.CURRENT,</span><br><span class="line">        group=group,</span><br><span class="line">        encoder=encoder,</span><br><span class="line">        dep=dep,</span><br><span class="line">        dep_value=dep_value,</span><br><span class="line">        dep_values=dep_values,</span><br><span class="line">        dep_compare=dep_compare,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ScopedBlock(block)</span><br></pre></td></tr></table></figure>



<h3 id="start-fuzz"><a href="#start-fuzz" class="headerlink" title="start fuzz"></a>start fuzz</h3><h4 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h4><p>fuzz开始于fuzz函数，传入一个request的name的话就只会fuzz这个request，不传就会按建立的图去遍历着fuzz。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuzz</span>(<span class="params">self, name=<span class="literal">None</span>, max_depth=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fuzz the entire protocol tree.</span></span><br><span class="line"><span class="string">    Iterates through and fuzzes all fuzz cases, skipping according to</span></span><br><span class="line"><span class="string">    self.skip and restarting based on self.restart_interval.</span></span><br><span class="line"><span class="string">    If you want the web server to be available, your program must persist</span></span><br><span class="line"><span class="string">    after calling this method. helpers.pause_for_signal() is</span></span><br><span class="line"><span class="string">    available to this end.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name (str): Pass in a Request name to fuzz only a single request message. Pass in a test case name to fuzz only a single test case.</span></span><br><span class="line"><span class="string">        max_depth (int): Maximum combinatorial depth; set to 1 for &quot;simple&quot; fuzzing.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.total_mutant_index = <span class="number">0</span></span><br><span class="line">    self.total_num_mutations = self.num_mutations(max_depth=max_depth)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> name == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        self._main_fuzz_loop(self._generate_mutations_indefinitely(max_depth=max_depth))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.fuzz_by_name(name=name)</span><br></pre></td></tr></table></figure>



<h4 id="main-fuzz-loop"><a href="#main-fuzz-loop" class="headerlink" title="_main_fuzz_loop"></a>_main_fuzz_loop</h4><p>1.首先会开启一个boofuzz的可视化web server；</p>
<p>2.调用<code>_start_target</code>启动target，一般测试服务器的时候，是我们手动启动目标服务器，所以用不到这个，但是配合<code>ProcMonitor</code>我们可以设置自启动目标(Windows平台)；</p>
<p>3.记录fuzz开始时间；</p>
<p>4.开始fuzz大循环，每次循环调用<code>_fuzz_current_case</code>进行fuzz；</p>
<p>5.<code>num_cases_actually_fuzzed+1</code>，如果<code>_index_end</code>参数不为空且<code>total_mutant_index</code>&gt;=<code>_index_end</code>的话就结束fuzz；</p>
<p>6.记录fuzz结束时间。</p>
<p>这里还有个选项是<code>_reuse_target_connection</code>，即重用连接。开启这个选项后，整个大循环中只会在这里open一次连接，如果不开这个选项，每次fuzz都会重新open一次连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_main_fuzz_loop</span>(<span class="params">self, fuzz_case_iterator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Execute main fuzz logic; takes an iterator of test cases.</span></span><br><span class="line"><span class="string">    Preconditions: `self.total_mutant_index` and `self.total_num_mutations` are set properly.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        fuzz_case_iterator (Iterable): An iterator that walks through fuzz cases and yields MutationContext objec</span></span><br><span class="line"><span class="string">             See _iterate_single_node() for details.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#这里是创建线程开启一个boofuzz的可视化web端口</span></span><br><span class="line">    <span class="keyword">if</span> self.web_port <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.server_init()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    self._start_target(self.targets[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> self._reuse_target_connection:</span><br><span class="line">        self.targets[<span class="number">0</span>].<span class="built_in">open</span>()</span><br><span class="line">    self.num_cases_actually_fuzzed = <span class="number">0</span></span><br><span class="line">    <span class="comment">#记录fuzz开始时间</span></span><br><span class="line">    self.start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> mutation_context <span class="keyword">in</span> fuzz_case_iterator:</span><br><span class="line">        <span class="keyword">if</span> self.total_mutant_index &lt; self._index_start:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># Check restart interval</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            self.num_cases_actually_fuzzed</span><br><span class="line">            <span class="keyword">and</span> self.restart_interval</span><br><span class="line">            <span class="keyword">and</span> self.num_cases_actually_fuzzed % self.restart_interval == <span class="number">0</span></span><br><span class="line">        ):</span><br><span class="line">            self._fuzz_data_logger.open_test_step(<span class="string">&quot;restart interval of %d reached&quot;</span> % self.restart_interval)</span><br><span class="line">            self._restart_target(self.targets[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#这里开始fuzz这次</span></span><br><span class="line">        self._fuzz_current_case(mutation_context)</span><br><span class="line">        <span class="comment">#这里是记录实际进行fuzz的次数</span></span><br><span class="line">        self.num_cases_actually_fuzzed += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._index_end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.total_mutant_index &gt;= self._index_end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> self._reuse_target_connection:</span><br><span class="line">        self.targets[<span class="number">0</span>].close()</span><br><span class="line">    <span class="keyword">if</span> self._keep_web_open <span class="keyword">and</span> self.web_port <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;\nFuzzing session completed. Keeping webinterface up on localhost:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.web_port),</span><br><span class="line">            <span class="string">&quot;\nPress ENTER to close webinterface&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>



<h4 id="start-target"><a href="#start-target" class="headerlink" title="_start_target"></a>_start_target</h4><p>内部调用monitor的<code>start_target</code>来启动目标，目标启动后，调用monitor的<code>post_start_target</code>回调函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_start_target</span>(<span class="params">self, target</span>):</span></span><br><span class="line">    started = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> monitor <span class="keyword">in</span> target.monitors:</span><br><span class="line">        <span class="keyword">if</span> monitor.start_target():</span><br><span class="line">            started = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> started:</span><br><span class="line">        <span class="keyword">for</span> monitor <span class="keyword">in</span> target.monitors:</span><br><span class="line">            monitor.post_start_target(target=target, fuzz_data_logger=self._fuzz_data_logger, session=self)</span><br></pre></td></tr></table></figure>



<h4 id="fuzz-current-case"><a href="#fuzz-current-case" class="headerlink" title="_fuzz_current_case"></a>_fuzz_current_case</h4><p>1.打印一些信息；</p>
<p>2.调用<code>_open_connection_keep_trying</code>打开连接，在这里可以实现自定义的网络状态monitor；</p>
<p>3.调用<code>_pre_send</code>函数，这里会调用monitor中的<code>pre_send</code>回调函数（Session处填的<code>pre_send_callback</code>会复制到<code>CallbackMonitor</code>的<code>on_pre_send</code>中，这里pre_send就会调用它们）具体可以看后面单独对<code>CallbackMonitor</code>的分析；</p>
<p>4.调用edge的callback函数，产生callback数据；</p>
<p>5.调用<code>transmit_fuzz</code>进行测试数据的收发；</p>
<p>6.调用<code>_check_for_passively_detected_failures</code>函数检查是否发生了crash。</p>
<p>根据设置的<code>sleep_time</code>参数暂停。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fuzz_current_case</span>(<span class="params">self, mutation_context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Fuzzes the current test case. Current test case is controlled by</span></span><br><span class="line"><span class="string">    fuzz_case_iterator().</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        mutation_context (MutationContext): Current mutation context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    target = self.targets[<span class="number">0</span>]</span><br><span class="line">    self._pause_if_pause_flag_is_set()</span><br><span class="line">    test_case_name = self._test_case_name(mutation_context)</span><br><span class="line">    self.current_test_case_name = test_case_name</span><br><span class="line">    self._fuzz_data_logger.open_test_case(</span><br><span class="line">        <span class="string">&quot;&#123;0&#125;: &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(self.total_mutant_index, test_case_name),</span><br><span class="line">        name=test_case_name,</span><br><span class="line">        index=self.total_mutant_index,</span><br><span class="line">        num_mutations=self.total_num_mutations,</span><br><span class="line">        current_index=self.mutant_index,</span><br><span class="line">        current_num_mutations=self.fuzz_node.get_num_mutations(),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> self.total_num_mutations <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._fuzz_data_logger.log_info(</span><br><span class="line">            <span class="string">&quot;Type: &#123;0&#125;. Case &#123;1&#125; of &#123;2&#125; overall.&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                <span class="built_in">type</span>(self.fuzz_node.mutant).__name__,</span><br><span class="line">                self.total_mutant_index,</span><br><span class="line">                self.total_num_mutations,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._fuzz_data_logger.log_info(</span><br><span class="line">            <span class="string">&quot;Type: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                <span class="built_in">type</span>(self.fuzz_node.mutant).__name__,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#打开连接</span></span><br><span class="line">        self._open_connection_keep_trying(target)</span><br><span class="line">        <span class="comment">#_pre_send被调用</span></span><br><span class="line">        self._pre_send(target)</span><br><span class="line">    	  <span class="comment">#这里是正常发送message_path最后一条路径前面的路径数据，这里就可以看出boofuzz是按node进行fuzz的</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> mutation_context.message_path[:-<span class="number">1</span>]:</span><br><span class="line">            prev_node = self.nodes[e.src]</span><br><span class="line">            node = self.nodes[e.dst]</span><br><span class="line">            protocol_session = ProtocolSession(</span><br><span class="line">                previous_message=prev_node,</span><br><span class="line">                current_message=node,</span><br><span class="line">            )</span><br><span class="line">            mutation_context.protocol_session = protocol_session</span><br><span class="line">            callback_data = self._callback_current_node(node=node, edge=e, test_case_context=protocol_session)</span><br><span class="line">            self._fuzz_data_logger.open_test_step(<span class="string">&quot;Transmit Prep Node &#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(node.name))</span><br><span class="line">            self.transmit_normal(target, node, e, callback_data=callback_data, mutation_context=mutation_context)</span><br><span class="line">        prev_node = self.nodes[mutation_context.message_path[-<span class="number">1</span>].src]</span><br><span class="line">        node = self.nodes[mutation_context.message_path[-<span class="number">1</span>].dst]</span><br><span class="line">        protocol_session = ProtocolSession(</span><br><span class="line">            previous_message=prev_node,</span><br><span class="line">            current_message=node,</span><br><span class="line">        )</span><br><span class="line">        mutation_context.protocol_session = protocol_session</span><br><span class="line">        <span class="comment">#这里会调用callback，同时返回一个callback数据</span></span><br><span class="line">        callback_data = self._callback_current_node(</span><br><span class="line">            node=self.fuzz_node, edge=mutation_context.message_path[-<span class="number">1</span>], test_case_context=protocol_session</span><br><span class="line">        )</span><br><span class="line">        self._fuzz_data_logger.open_test_step(<span class="string">&quot;Fuzzing Node &#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(self.fuzz_node.name))</span><br><span class="line">        <span class="comment">#进行实际的数据发送</span></span><br><span class="line">        self.transmit_fuzz(</span><br><span class="line">            target,</span><br><span class="line">            self.fuzz_node,</span><br><span class="line">            mutation_context.message_path[-<span class="number">1</span>],</span><br><span class="line">            callback_data=callback_data,</span><br><span class="line">            mutation_context=mutation_context,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#检查是否发生了crash</span></span><br><span class="line">        self._check_for_passively_detected_failures(target=target)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._reuse_target_connection:</span><br><span class="line">            target.close()</span><br><span class="line">        <span class="comment">#这里也提供了接口来睡眠</span></span><br><span class="line">        <span class="keyword">if</span> self.sleep_time &gt; <span class="number">0</span>:</span><br><span class="line">            self._fuzz_data_logger.open_test_step(<span class="string">&quot;Sleep between tests.&quot;</span>)</span><br><span class="line">            self._sleep(self.sleep_time)</span><br></pre></td></tr></table></figure>



<h4 id="open-connection-keep-trying"><a href="#open-connection-keep-trying" class="headerlink" title="_open_connection_keep_trying"></a>_open_connection_keep_trying</h4><p>在不开启<code>_reuse_target_connection</code>的情况下调用target的open函数，代码中已经实现了自定义的网络状态monitor。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_open_connection_keep_trying</span>(<span class="params">self, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Open connection and if it fails, keep retrying.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        target (Target): Target to open.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#只有不开_reuse_target_connection的时候才会open</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._reuse_target_connection:</span><br><span class="line">        out_of_available_sockets_count = <span class="number">0</span></span><br><span class="line">        unable_to_connect_count = <span class="number">0</span></span><br><span class="line">        initial_time = time.time()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#内部就是调用target的open函数，前面已经分析了</span></span><br><span class="line">                target.<span class="built_in">open</span>()</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># break if no exception</span></span><br><span class="line">            <span class="keyword">except</span> exception.BoofuzzTargetConnectionFailedError:</span><br><span class="line">                <span class="keyword">if</span> self.restart_threshold <span class="keyword">and</span> unable_to_connect_count &gt;= self.restart_threshold:</span><br><span class="line">                    self._fuzz_data_logger.log_info(</span><br><span class="line">                        <span class="string">&quot;Unable to reconnect to target: Reached threshold of &#123;0&#125; retries. Ending fuzzing.&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                            self.restart_threshold</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                    <span class="comment">#自添加代码，实现网络状态的Monitor</span></span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(self.crash_filename + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(self.num_cases_actually_fuzzed),<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                        fp.write((self.current_test_case_name+<span class="string">&quot;\n&quot;</span>).encode())</span><br><span class="line">                        fp.write(self.last_send)</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line">                <span class="keyword">elif</span> self.restart_timeout <span class="keyword">and</span> time.time() &gt;= initial_time + self.restart_timeout:</span><br><span class="line">                    self._fuzz_data_logger.log_info(</span><br><span class="line">                        <span class="string">&quot;Unable to reconnect to target: Reached restart timeout of &#123;0&#125;s. Ending fuzzing.&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                            self.restart_timeout</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self._fuzz_data_logger.log_info(constants.WARN_CONN_FAILED_TERMINAL)</span><br><span class="line">                    self._restart_target(target)</span><br><span class="line">                    unable_to_connect_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> exception.BoofuzzOutOfAvailableSockets:</span><br><span class="line">                out_of_available_sockets_count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> out_of_available_sockets_count == <span class="number">50</span>:</span><br><span class="line">                    <span class="keyword">raise</span> exception.BoofuzzError(<span class="string">&quot;There are no available sockets. Ending fuzzing.&quot;</span>)</span><br><span class="line">                self._fuzz_data_logger.log_info(<span class="string">&quot;There are no available sockets. Waiting for another 5 seconds.&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<h4 id="pre-send"><a href="#pre-send" class="headerlink" title="_pre_send"></a>_pre_send</h4><p>依次调用target的monitor中的回调函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pre_send</span>(<span class="params">self, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Execute custom methods to run prior to each fuzz request. The order of events is as follows::</span></span><br><span class="line"><span class="string">        pre_send() - req - callback ... req - callback - post_send()</span></span><br><span class="line"><span class="string">    When fuzzing RPC for example, register this method to establish the RPC bind.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        target (session.target): Target we are sending data to</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> monitor <span class="keyword">in</span> target.monitors:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._fuzz_data_logger.open_test_step(<span class="string">&quot;Monitor &#123;&#125;.pre_send()&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(monitor)))</span><br><span class="line">            monitor.pre_send(target=target, fuzz_data_logger=self._fuzz_data_logger, session=self)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self._fuzz_data_logger.log_error(</span><br><span class="line">                constants.ERR_CALLBACK_FUNC.<span class="built_in">format</span>(func_name=<span class="string">&quot;&#123;&#125;.pre_send()&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(monitor)))</span><br><span class="line">                + traceback.format_exc()</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>



<h4 id="callback-current-node"><a href="#callback-current-node" class="headerlink" title="_callback_current_node"></a>_callback_current_node</h4><p>调用当前边edge的callback函数，并返回callback数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_callback_current_node</span>(<span class="params">self, node, edge, test_case_context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Execute callback preceding current node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        test_case_context (ProtocolSession): Context for test case-scoped data.</span></span><br><span class="line"><span class="string">        node (pgraph.node.node (Node), optional): Current Request/Node</span></span><br><span class="line"><span class="string">        edge (pgraph.edge.edge (pgraph.edge), optional): Edge along the current fuzz path from &quot;node&quot; to next node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bytes: Data rendered by current node if any; otherwise None.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if the edge has a callback, process it. the callback has the option to render the node, modify it and return.</span></span><br><span class="line">    <span class="comment">#调用edge的callback函数，并返回callback数据</span></span><br><span class="line">    <span class="keyword">if</span> edge.callback:</span><br><span class="line">        self._fuzz_data_logger.open_test_step(<span class="string">&quot;Callback function &#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(edge.callback.__name__))</span><br><span class="line">        data = edge.callback(</span><br><span class="line">            self.targets[<span class="number">0</span>],</span><br><span class="line">            self._fuzz_data_logger,</span><br><span class="line">            session=self,</span><br><span class="line">            node=node,</span><br><span class="line">            edge=edge,</span><br><span class="line">            test_case_context=test_case_context,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>



<h4 id="check-for-passively-detected-failures"><a href="#check-for-passively-detected-failures" class="headerlink" title="_check_for_passively_detected_failures"></a>_check_for_passively_detected_failures</h4><p>依次调用monitor的<code>post_send</code>函数来获取是否发生了crash，如果发生了crash就继续调用<code>get_crash_synopsis</code>函数来获取crash概要。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_check_for_passively_detected_failures</span>(<span class="params">self, target, failure_already_detected=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Check for and log passively detected failures. Return True if any found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        target (Target): Target to be checked for failures.</span></span><br><span class="line"><span class="string">        failure_already_detected (bool): If a failure was already detected.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bool: True if failures were found. False otherwise.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    has_crashed = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(target.monitors) &gt; <span class="number">0</span>:</span><br><span class="line">        self._fuzz_data_logger.open_test_step(<span class="string">&quot;Contact target monitors&quot;</span>)</span><br><span class="line">        <span class="comment"># So, we need to run through the array two times. First, we check</span></span><br><span class="line">        <span class="comment"># if any of the monitors reported a failure and</span></span><br><span class="line">        <span class="comment"># if so, we need to</span></span><br><span class="line">        <span class="comment"># gather a crash synopsis from them. We don&#x27;t know whether</span></span><br><span class="line">        <span class="comment"># a monitor can provide a crash synopsis, but in any case, we&#x27;ll</span></span><br><span class="line">        <span class="comment"># check. In the second run, we try to get crash synopsis from the</span></span><br><span class="line">        <span class="comment"># monitors that did not detect a crash as supplemental information.</span></span><br><span class="line">        finished_monitors = []</span><br><span class="line">        <span class="comment">#依次调用monitor的post_send函数</span></span><br><span class="line">        <span class="keyword">for</span> monitor <span class="keyword">in</span> target.monitors:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> monitor.post_send(target=target, fuzz_data_logger=self._fuzz_data_logger, session=self):</span><br><span class="line">                has_crashed = <span class="literal">True</span></span><br><span class="line">                self._fuzz_data_logger.log_fail(</span><br><span class="line">                    <span class="string">&quot;&#123;0&#125; detected crash on test case #&#123;1&#125;: &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                        <span class="built_in">str</span>(monitor), self.total_mutant_index, monitor.get_crash_synopsis()</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">                finished_monitors.append(monitor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> has_crashed <span class="keyword">and</span> <span class="keyword">not</span> failure_already_detected:</span><br><span class="line">            self._fuzz_data_logger.log_pass(<span class="string">&quot;No crash detected.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> monitor <span class="keyword">in</span> <span class="built_in">set</span>(target.monitors) - <span class="built_in">set</span>(finished_monitors):</span><br><span class="line"></span><br><span class="line">                synopsis = monitor.get_crash_synopsis()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(synopsis) &gt; <span class="number">0</span>:</span><br><span class="line">                    self._fuzz_data_logger.log_fail(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125; provided additional information for crash on #&#123;1&#125;: &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                            <span class="built_in">str</span>(monitor), self.total_mutant_index, monitor.get_crash_synopsis()</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">    <span class="keyword">return</span> has_crashed</span><br></pre></td></tr></table></figure>



<h4 id="transmit-fuzz"><a href="#transmit-fuzz" class="headerlink" title="transmit_fuzz"></a>transmit_fuzz</h4><p>进行实际的数据收发：</p>
<p>1.判断是否传入了callback数据，如果有callback数据就使用callback数据，否则调用render来产生变异数据；</p>
<p>2.发送数据，并将发送的数据保存在<code>last_send</code>中；</p>
<p>3.接受数据，并将接受的数据保存在<code>last_recv</code>中。</p>
<p><code>last_send</code>和<code>last_recv</code>都非常重要，<code>last_send</code>可以在监测crash时dump出来作为crash样本，<code>last_recv</code>则可以在边回调中决定状态机的走向，以及产生callback数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transmit_fuzz</span>(<span class="params">self, sock, node, edge, callback_data, mutation_context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Render and transmit a fuzzed node, process callbacks accordingly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        sock (Target, optional): Socket-like object on which to transmit node</span></span><br><span class="line"><span class="string">        node (pgraph.node.node (Node), optional): Request/Node to transmit</span></span><br><span class="line"><span class="string">        edge (pgraph.edge.edge (pgraph.edge), optional): Edge along the current fuzz path from &quot;node&quot; to next node.</span></span><br><span class="line"><span class="string">        callback_data (bytes): Data from previous callback.</span></span><br><span class="line"><span class="string">        mutation_context (MutationContext): Current mutation context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#这里就可以看到，边的callback是先于数据发送的，如果callback返回了自定义数据，那这里就会直接拿callback返回的数据发送</span></span><br><span class="line">    <span class="comment">#如果callback返回空数据，这里就会正常调用变异的数据渲染，然后发送变异数据</span></span><br><span class="line">    <span class="keyword">if</span> callback_data:</span><br><span class="line">        data = callback_data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = self.fuzz_node.render(mutation_context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># send</span></span><br><span class="line">        <span class="comment">#这里发送变异数据，同时将发送的数据保存在last_send里面</span></span><br><span class="line">        self.targets[<span class="number">0</span>].send(data)</span><br><span class="line">        self.last_send = data</span><br><span class="line">    <span class="keyword">except</span> exception.BoofuzzTargetConnectionReset:</span><br><span class="line">        <span class="keyword">if</span> self._ignore_connection_issues_when_sending_fuzz_data:</span><br><span class="line">            self._fuzz_data_logger.log_info(constants.ERR_CONN_RESET)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> BoofuzzFailure(message=constants.ERR_CONN_RESET)</span><br><span class="line">    <span class="keyword">except</span> exception.BoofuzzTargetConnectionAborted <span class="keyword">as</span> e:</span><br><span class="line">        msg = constants.ERR_CONN_ABORTED.<span class="built_in">format</span>(socket_errno=e.socket_errno, socket_errmsg=e.socket_errmsg)</span><br><span class="line">        <span class="keyword">if</span> self._ignore_connection_issues_when_sending_fuzz_data:</span><br><span class="line">            self._fuzz_data_logger.log_info(msg)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> BoofuzzFailure(msg)</span><br><span class="line">    <span class="keyword">except</span> exception.BoofuzzSSLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> self._ignore_connection_ssl_errors:</span><br><span class="line">            self._fuzz_data_logger.log_info(<span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> BoofuzzFailure(<span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">    received = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># recv</span></span><br><span class="line">        <span class="keyword">if</span> self._receive_data_after_fuzz:</span><br><span class="line">            received = self.targets[<span class="number">0</span>].recv()</span><br><span class="line">    <span class="keyword">except</span> exception.BoofuzzTargetConnectionReset:</span><br><span class="line">        <span class="keyword">if</span> self._check_data_received_each_request:</span><br><span class="line">            <span class="keyword">raise</span> BoofuzzFailure(message=constants.ERR_CONN_RESET)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._fuzz_data_logger.log_info(constants.ERR_CONN_RESET)</span><br><span class="line">    <span class="keyword">except</span> exception.BoofuzzTargetConnectionAborted <span class="keyword">as</span> e:</span><br><span class="line">        msg = constants.ERR_CONN_ABORTED.<span class="built_in">format</span>(socket_errno=e.socket_errno, socket_errmsg=e.socket_errmsg)</span><br><span class="line">        <span class="keyword">if</span> self._check_data_received_each_request:</span><br><span class="line">            <span class="keyword">raise</span> BoofuzzFailure(msg)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._fuzz_data_logger.log_info(msg)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> exception.BoofuzzSSLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> self._ignore_connection_ssl_errors:</span><br><span class="line">            self._fuzz_data_logger.log_info(<span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._fuzz_data_logger.log_fail(<span class="built_in">str</span>(e))</span><br><span class="line">            <span class="keyword">raise</span> BoofuzzFailure(<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="comment">#这里会将这次接受到的数据保存在last_recv里面</span></span><br><span class="line">    self.last_recv = received</span><br></pre></td></tr></table></figure>



<h4 id="crash-dump"><a href="#crash-dump" class="headerlink" title="crash dump"></a>crash dump</h4><p>上面只介绍到监测crash而没说哪里dump crash，实际上crash的dump在各个Monitor中(在<code>_fuzz_current_case</code>函数中是没有的)。</p>
<p>以Procmon的<code>DebugThread</code>为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_send</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This routine is called after the fuzzer transmits a test case and returns the status of the target.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bool: True if the target is still active, False otherwise.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.is_alive():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.process_monitor.crash_filename, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> rec_file:</span><br><span class="line">            rec_file.write(self.process_monitor.last_synopsis)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.process_monitor.coredump_dir <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            dest = os.path.join(self.process_monitor.coredump_dir, <span class="built_in">str</span>(self.process_monitor.test_number))</span><br><span class="line">            src = _get_coredump_path()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> src <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.log(<span class="string">&quot;moving core dump %s -&gt; %s&quot;</span> % (src, dest))</span><br><span class="line">                os.rename(src, dest)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>到此为止，数据的收发流程基本就了解了，剩下需要看下数据是怎么从request中产生并变异的。</p>
<h3 id="数据变异"><a href="#数据变异" class="headerlink" title="数据变异"></a>数据变异</h3><p><code>_generate_mutations_indefinitely</code>这里会产生一个iterator，迭代产生<code>mutation_context</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> name == <span class="string">&quot;&quot;</span>:</span><br><span class="line">    self._main_fuzz_loop(self._generate_mutations_indefinitely(max_depth=max_depth))</span><br></pre></td></tr></table></figure>



<h4 id="generate-mutations-indefinitely"><a href="#generate-mutations-indefinitely" class="headerlink" title="_generate_mutations_indefinitely"></a>_generate_mutations_indefinitely</h4><p>这里<code>max_path</code>默认传进来是个none。</p>
<p>调用<code>_generate_n_mutations</code>来产生<code>mutation_context</code>。</p>
<p>depth是在一次<code>fuzz_case</code>中，产生几个变异体：depth为1，那就是一次就变异一个primitive。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_mutations_indefinitely</span>(<span class="params">self, max_depth=<span class="literal">None</span>, path=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yield MutationContext with n mutations per message over all messages, with n increasing indefinitely.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># indefinitely 无限期的</span></span><br><span class="line">    depth = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> max_depth <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> depth &lt;= max_depth:</span><br><span class="line">        valid_case_found_at_this_depth = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self._generate_n_mutations(depth=depth, path=path):</span><br><span class="line">            valid_case_found_at_this_depth = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">yield</span> m</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> valid_case_found_at_this_depth:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        depth += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="generate-n-mutations"><a href="#generate-n-mutations" class="headerlink" title="_generate_n_mutations"></a>_generate_n_mutations</h4><p>这里会先得到path再从path里得到要fuzz的node。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_n_mutations</span>(<span class="params">self, depth, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yield MutationContext with n mutations per message over all messages.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#调试此处的yield</span></span><br><span class="line">    <span class="comment"># for path in self._iterate_protocol_message_paths(path=path):</span></span><br><span class="line">    <span class="comment">#     print(self._message_path_to_str(path))</span></span><br><span class="line">    <span class="comment">#先得到要fuzz的path，再从中获取要fuzz的node</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> self._iterate_protocol_message_paths(path=path):</span><br><span class="line">        <span class="comment">#_generate_n_mutations_for_path这个函数会根据上面取得的path构建MutationContext</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self._generate_n_mutations_for_path(path, depth=depth):</span><br><span class="line">            <span class="keyword">yield</span> m</span><br></pre></td></tr></table></figure>



<h4 id="iterate-protocol-message-paths"><a href="#iterate-protocol-message-paths" class="headerlink" title="_iterate_protocol_message_paths"></a>_iterate_protocol_message_paths</h4><p>先检查下是否有target以及从root发出的边。</p>
<p>如果指定了path，就直接返回指定的path，但是默认为空。</p>
<p>调用<code>_iterate_protocol_message_paths_recursive</code>遍历path。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_iterate_protocol_message_paths</span>(<span class="params">self, path=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Iterates over protocol and yields a path (list of Connection) leading to a given message).</span></span><br><span class="line"><span class="string">    #如果指定了path的集合，就返回这个指定的边的集合，否则就遍历整个协议中所有的边的可能性</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path (list of Connection): Provide a specific path to yield only that specific path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        list of Connection: List of edges along the path to the current one being fuzzed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        exception.SulleyRuntimeError: If no requests defined or no targets specified</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># we can&#x27;t fuzz if we don&#x27;t have at least one target and one request.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.targets:</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;No targets specified in session&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.edges_from(self.root.<span class="built_in">id</span>):</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;No requests specified in session&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> path <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">yield</span> path</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self._iterate_protocol_message_paths_recursive(this_node=self.root, path=[]):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure>



<h4 id="iterate-protocol-message-paths-recursive"><a href="#iterate-protocol-message-paths-recursive" class="headerlink" title="_iterate_protocol_message_paths_recursive"></a>_iterate_protocol_message_paths_recursive</h4><p>这里遍历path的方法使用的是DFS，只不过用yield实现的，看着有些别扭，最终会产生从root出发的所有路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_iterate_protocol_message_paths_recursive</span>(<span class="params">self, this_node, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Recursive helper for _iterate_protocol.</span></span><br><span class="line"><span class="string">    #迭代的去取该协议中的msg的path</span></span><br><span class="line"><span class="string">    #这里应该是会返回所有路径</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        this_node (node.Node): Current node that is being fuzzed.</span></span><br><span class="line"><span class="string">        path (list of Connection): List of edges along the path to the current one being fuzzed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        list of Connection: List of edges along the path to the current one being fuzzed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># step through every edge from the current node.</span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges_from(this_node.<span class="built_in">id</span>):</span><br><span class="line">        <span class="comment"># keep track of the path as we fuzz through it, don&#x27;t count the root node.</span></span><br><span class="line">        <span class="comment"># we keep track of edges as opposed to nodes because if there is more then one path through a set of</span></span><br><span class="line">        <span class="comment"># given nodes we don&#x27;t want any ambiguity.</span></span><br><span class="line">        path.append(edge)</span><br><span class="line"></span><br><span class="line">        message_path = self._message_path_to_str(path)</span><br><span class="line">        logging.debug(<span class="string">&quot;fuzzing: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(message_path))</span><br><span class="line">        self.fuzz_node = self.nodes[path[-<span class="number">1</span>].dst]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># recursively fuzz the remainder of the nodes in the session graph.</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self._iterate_protocol_message_paths_recursive(self.fuzz_node, path):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># finished with the last node on the path, pop it off the path stack.</span></span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>



<h4 id="generate-n-mutations-for-path"><a href="#generate-n-mutations-for-path" class="headerlink" title="_generate_n_mutations_for_path"></a>_generate_n_mutations_for_path</h4><p>知道path如何产生的之后再回去看<code>    MutationContext</code>是怎么产生的，<code>_generate_n_mutations_for_path</code>函数对传进来的path产生<code>mutation_context</code>，<code>mutation_context</code>就是代表这次case的变异体上下文，depth是标识一个<code>fuzz_case</code>使用几个变异体,默认为1。</p>
<p>那么<code>MutationContext</code>的mutations就只有一个<code>qualified_name</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_n_mutations_for_path</span>(<span class="params">self, path, depth</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yield MutationContext with n mutations for a specific message.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path (list of Connection): Nodes (Requests) along the path to the current one being fuzzed.</span></span><br><span class="line"><span class="string">        depth (int): Yield sets of depth mutations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        MutationContext: A MutationContext containing one mutation.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> mutations <span class="keyword">in</span> self._generate_n_mutations_for_path_recursive(path, depth=depth):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._mutations_contain_duplicate(mutations):</span><br><span class="line">            self.total_mutant_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> MutationContext(message_path=path, mutations=&#123;n.qualified_name: n <span class="keyword">for</span> n <span class="keyword">in</span> mutations&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="generate-n-mutations-for-path-recursive"><a href="#generate-n-mutations-for-path-recursive" class="headerlink" title="_generate_n_mutations_for_path_recursive"></a>_generate_n_mutations_for_path_recursive</h4><p>调用<code>_generate_n_mutations_for_path_recursive</code>产生mutation集合。</p>
<p>mutaions由两个部分组成，一个是<code>_generate_mutations_for_request</code>函数产生的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_n_mutations_for_path_recursive</span>(<span class="params">self, path, depth, skip_elements=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> skip_elements <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        skip_elements = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> depth == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> []</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    new_skip = skip_elements.copy()</span><br><span class="line">    <span class="comment"># 调试yield</span></span><br><span class="line">    <span class="comment"># for mutations in self._generate_mutations_for_request(path=path, skip_elements=skip_elements):</span></span><br><span class="line">    <span class="comment">#     print(mutations)</span></span><br><span class="line">    <span class="keyword">for</span> mutations <span class="keyword">in</span> self._generate_mutations_for_request(path=path, skip_elements=skip_elements):</span><br><span class="line">        new_skip.update(m.qualified_name <span class="keyword">for</span> m <span class="keyword">in</span> mutations)</span><br><span class="line">        <span class="keyword">for</span> ms <span class="keyword">in</span> self._generate_n_mutations_for_path_recursive(path, depth=depth - <span class="number">1</span>, skip_elements=new_skip):</span><br><span class="line">            <span class="keyword">yield</span> mutations + ms</span><br></pre></td></tr></table></figure>



<h4 id="generate-mutations-for-request"><a href="#generate-mutations-for-request" class="headerlink" title="_generate_mutations_for_request"></a>_generate_mutations_for_request</h4><p>设置<code>fuzz_node</code>为当前路径上的最后一个node，之后调用<code>fuzz_node</code>的<code>get_mutations</code>，<code>fuzz_node</code>是一个request对象，所以这里调用的是request的<code>get_mutations</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_mutations_for_request</span>(<span class="params">self, path, skip_elements=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yield each mutation for a specific message (the last message in path).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path (list of Connection): Nodes (Requests) along the path to the current one being fuzzed.</span></span><br><span class="line"><span class="string">        path (iter of str): Qualified names of elements to skip while fuzzing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        Mutation: Mutation object describing a single mutation.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> skip_elements <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        skip_elements = []</span><br><span class="line">    <span class="comment">#这里设置fuzz_node为当前fuzz路径的dst</span></span><br><span class="line">    self.fuzz_node = self.nodes[path[-<span class="number">1</span>].dst]</span><br><span class="line">    self.mutant_index = <span class="number">0</span></span><br><span class="line">    <span class="comment">#调试yield</span></span><br><span class="line">    <span class="comment">#value_list = list(self.fuzz_node.get_mutations(skip_elements=skip_elements))</span></span><br><span class="line">    <span class="comment">#这里会对node里的item枚举产生mutation</span></span><br><span class="line">    <span class="keyword">for</span> mutations <span class="keyword">in</span> self.fuzz_node.get_mutations(skip_elements=skip_elements):</span><br><span class="line">        <span class="comment">#记录整体的已经发生的变异次数</span></span><br><span class="line">        self.mutant_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> mutations</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._skip_current_node_after_current_test_case:</span><br><span class="line">            self._skip_current_node_after_current_test_case = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> self._skip_current_element_after_current_test_case:</span><br><span class="line">            self.fuzz_node.mutant.stop_mutations()</span><br><span class="line">            self._skip_current_element_after_current_test_case = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>



<h4 id="request-get-mutations"><a href="#request-get-mutations" class="headerlink" title="request.get_mutations"></a>request.get_mutations</h4><p>Request继承自<code>FuzzableBlock</code>，mutations是<code>FuzzableBlock</code>的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mutations</span>(<span class="params">self, default_value=<span class="literal">None</span>, skip_elements=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.mutations(default_value=default_value, skip_elements=skip_elements)</span><br></pre></td></tr></table></figure>



<h4 id="FuzzableBlock-mutations"><a href="#FuzzableBlock-mutations" class="headerlink" title="FuzzableBlock.mutations"></a>FuzzableBlock.mutations</h4><p>遍历当前request的stack中的item，即插入的block和primitive，再调用他们的<code>get_mutations</code>函数得到mutation。</p>
<p>primitives都继承自fuzzable，所以这里调用的是fuzzable的<code>get_mutations</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutations</span>(<span class="params">self, default_value, skip_elements=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> skip_elements <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        skip_elements = []</span><br><span class="line">    <span class="comment">#遍历stack中的item</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> self.stack:</span><br><span class="line">        <span class="keyword">if</span> item.qualified_name <span class="keyword">in</span> skip_elements:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        self.request.mutant = item</span><br><span class="line">        <span class="keyword">for</span> mutation <span class="keyword">in</span> item.get_mutations():</span><br><span class="line">            <span class="keyword">yield</span> mutation</span><br></pre></td></tr></table></figure>



<h4 id="fuzzable-get-mutations"><a href="#fuzzable-get-mutations" class="headerlink" title="fuzzable.get_mutations"></a>fuzzable.get_mutations</h4><p>这个函数就是对当前item进行变异，并将变异的值传到生成的Mutation里面。</p>
<p>Mutation的构造这里就能看到，是由一个值value，一个所属item的<code>qualified_name</code>，以及变异计数index组成的。</p>
<p>这里终止变异用的是<code>_halt_mutations</code>标志，而<code>stop_mutations</code>函数是提供的接口，其内部就是设置<code>_halt_mutations</code>为true。</p>
<p><code>itertools.chain</code>的功能就是合并列表，所以这里值得来源就为<code>self.mutations(self.original_value())</code>，<code>self._fuzz_values</code>。</p>
<p>其中<code>_fuzz_values</code>在Fuzzable的<em>init</em>函数中是可以作为构造参数传入的，但是String（继承自Fuzzble）的构造函数里并没有这个参数，所以就没找到接口设置这个值(除了手动赋值)，所以这里总是空列表。</p>
<p>下面会以String为例，分析了其mutations函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mutations</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterate mutations. Used by boofuzz framework.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        list of Mutation: Mutations</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.fuzzable:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="comment">#value_list = list(itertools.chain(self.mutations(self.original_value()), self._fuzz_values))</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> itertools.chain(self.mutations(self.original_value()), self._fuzz_values):</span><br><span class="line">            <span class="comment">#这里是我自己添加的，当mutate进行200次后，就停止对这个item的mutate，以加速path的遍历，要不然会一直卡在对这一个item的遍历上</span></span><br><span class="line">            <span class="keyword">if</span> index&gt;<span class="number">200</span>:</span><br><span class="line">                self.stop_mutations()</span><br><span class="line">            <span class="keyword">if</span> self._halt_mutations:</span><br><span class="line">                self._halt_mutations = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">list</span>):</span><br><span class="line">                <span class="keyword">yield</span> value</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(value, Mutation):</span><br><span class="line">                <span class="keyword">yield</span> [value]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> [Mutation(value=value, qualified_name=self.qualified_name, index=index)]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._halt_mutations = <span class="literal">False</span>  <span class="comment"># in case stop_mutations is called when mutations were exhausted anyway</span></span><br></pre></td></tr></table></figure>



<h4 id="stop-mutations"><a href="#stop-mutations" class="headerlink" title="stop_mutations"></a>stop_mutations</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_mutations</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Stop yielding mutations on the currently running :py:meth:`mutations` call.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Used by boofuzz to stop fuzzing an element when it&#x27;s already caused several failures.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        NoneType: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._halt_mutations = <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h4 id="String-mutation"><a href="#String-mutation" class="headerlink" title="String.mutation"></a>String.mutation</h4><p>这里进一步可以看到变异值有三个来源：</p>
<p><code>_fuzz_library</code> 可以理解为预置的容易产生crash的字典；</p>
<p><code>_yield_variable_mutations(default_value)</code> 对<code>default_value</code>进行重叠以产生变异值；</p>
<p><code>_yield_long_strings(self.long_string_seeds)</code> 带点随机性的变异，(随机替换字符为终结符)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutations</span>(<span class="params">self, default_value</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Mutate the primitive by stepping through the fuzz library extended with the &quot;this&quot; library, return False on</span></span><br><span class="line"><span class="string">    completion.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        default_value (str): Default value of element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        str: Mutations</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    last_val = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> itertools.chain(</span><br><span class="line">        self._fuzz_library,</span><br><span class="line">        self._yield_variable_mutations(default_value),</span><br><span class="line">        self._yield_long_strings(self.long_string_seeds),</span><br><span class="line">    ):</span><br><span class="line">        current_val = self._adjust_mutation_for_size(val)</span><br><span class="line">        <span class="keyword">if</span> last_val == current_val:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        last_val = current_val</span><br><span class="line">        <span class="keyword">yield</span> current_val</span><br></pre></td></tr></table></figure>



<h4 id="fuzz-library-只贴了一部分"><a href="#fuzz-library-只贴了一部分" class="headerlink" title="_fuzz_library (只贴了一部分)"></a>_fuzz_library (只贴了一部分)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># store fuzz_library as a class variable to avoid copying the ~70MB structure across each instantiated primitive.</span></span><br><span class="line"><span class="comment"># Has to be sorted to avoid duplicates</span></span><br><span class="line">_fuzz_library = [</span><br><span class="line">    <span class="string">&quot;!@#$%%^#$%#$@#$%$$@#$%^^**(()&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,  <span class="comment"># strings ripped from spike (and some others I added)</span></span><br><span class="line">    <span class="string">&quot;$(reboot)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$;reboot&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%00&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%00/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%01%02%03%04%0a%0d%0aADSF&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%01%02%03@%04%0a%0d%0aADSF&quot;</span>,</span><br><span class="line">    <span class="string">&quot;%0a reboot %0a&quot;</span>,</span><br></pre></td></tr></table></figure>



<h4 id="yield-variable-mutations"><a href="#yield-variable-mutations" class="headerlink" title="_yield_variable_mutations"></a>_yield_variable_mutations</h4><p>重叠产生变异值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_variable_mutation_multipliers = [<span class="number">2</span>, <span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_yield_variable_mutations</span>(<span class="params">self, default_value</span>):</span></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> self._variable_mutation_multipliers:</span><br><span class="line">        value = default_value * length</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> self._fuzz_library:</span><br><span class="line">            <span class="keyword">yield</span> value</span><br><span class="line">            <span class="keyword">if</span> self.max_len <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(value) &gt;= self.max_len:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h4 id="yield-long-strings"><a href="#yield-long-strings" class="headerlink" title="_yield_long_strings"></a>_yield_long_strings</h4><p>这个函数有两部分，第一部分仍然是采取重叠的策略来产生变异值，只不过seed来自于<code>long_string_seeds</code>。</p>
<p><code>random.sample(list,size)</code>的功能是随机抽样，从list中抽size个数。</p>
<p>第二部分是先按<code>_long_string_lengths</code>中的长度产生一个D*size的字符串，然后再随机将其中的字符替换成/00,这是整个String的变异过程中唯一随机的部分。替换哪些位置的字符是在String初始化时已经按<code>_long_string_lengths</code>中的长度初始化过了（random_indices）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传进去的sequences</span></span><br><span class="line">long_string_seeds = [<span class="string">&quot;C&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;&gt;&quot;</span>,<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;?&quot;</span>,<span class="string">&quot;=&quot;</span>,<span class="string">&quot;a=&quot;</span>,<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;,&quot;</span>,<span class="string">&quot;(&quot;</span>,<span class="string">&quot;)&quot;</span>,<span class="string">&quot;]&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;%&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;\x14&quot;</span>,<span class="string">&quot;\x00&quot;</span>,<span class="string">&quot;\xFE&quot;</span>,]</span><br><span class="line">_long_string_lengths = [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">32768</span>, <span class="number">0xFFFF</span>]</span><br><span class="line">_long_string_deltas = [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">_extra_long_string_lengths = [<span class="number">99999</span>, <span class="number">100000</span>, <span class="number">500000</span>, <span class="number">1000000</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_yield_long_strings</span>(<span class="params">self, sequences</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a sequence, yield a number of selectively chosen strings lengths of the given sequence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @type  sequences: list(str)</span></span><br><span class="line"><span class="string">    @param sequences: Sequence to repeat for creation of fuzz strings.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#也是重叠的策略，只不过这里是从long_string_seeds中选出sequence来进行重叠</span></span><br><span class="line">    <span class="keyword">for</span> sequence <span class="keyword">in</span> sequences:</span><br><span class="line">        <span class="comment">#按_long_string_lengths和_long_string_deltas结合产生的长度产生(标准)</span></span><br><span class="line">        <span class="keyword">for</span> size <span class="keyword">in</span> [</span><br><span class="line">            length + delta</span><br><span class="line">            <span class="keyword">for</span> length, delta <span class="keyword">in</span> itertools.product(self._long_string_lengths, self._long_string_deltas)</span><br><span class="line">        ]:</span><br><span class="line">            <span class="keyword">if</span> self.max_len <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> size &lt;= self.max_len:</span><br><span class="line">                data = sequence * math.ceil(size / <span class="built_in">len</span>(sequence))</span><br><span class="line">                <span class="keyword">yield</span> data[:size]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">		<span class="comment">#按_extra_long_string_lengths中的长度产生(额外定义)</span></span><br><span class="line">        <span class="keyword">for</span> size <span class="keyword">in</span> self._extra_long_string_lengths:</span><br><span class="line">            <span class="keyword">if</span> self.max_len <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> size &lt;= self.max_len:</span><br><span class="line">                data = sequence * math.ceil(size / <span class="built_in">len</span>(sequence))</span><br><span class="line">                <span class="keyword">yield</span> data[:size]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">		<span class="comment">#按最大长度产生</span></span><br><span class="line">        <span class="keyword">if</span> self.max_len <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            data = sequence * math.ceil(self.max_len / <span class="built_in">len</span>(sequence))</span><br><span class="line">            <span class="keyword">yield</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> size <span class="keyword">in</span> self._long_string_lengths:</span><br><span class="line">        <span class="keyword">if</span> self.max_len <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> size &lt;= self.max_len:</span><br><span class="line">            s = <span class="string">&quot;D&quot;</span> * size</span><br><span class="line">            <span class="keyword">for</span> loc <span class="keyword">in</span> self.random_indices[size]:</span><br><span class="line">                <span class="keyword">yield</span> s[:loc] + <span class="string">&quot;\x00&quot;</span> + s[loc + <span class="number">1</span> :]  <span class="comment"># Replace character at loc with terminator</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#def  init():</span></span><br><span class="line">        self.random_indices = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        local_random = random.Random(<span class="number">0</span>)  <span class="comment"># We want constant random numbers to generate reproducible test cases</span></span><br><span class="line">        previous_length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># For every length add a random number of random indices to the random_indices dict. Prevent duplicates by</span></span><br><span class="line">        <span class="comment"># adding only indices in between previous_length and current length.</span></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> self._long_string_lengths:</span><br><span class="line">            self.random_indices[length] = local_random.sample(</span><br><span class="line">                <span class="built_in">range</span>(previous_length, length), local_random.randint(<span class="number">1</span>, self._long_string_lengths[<span class="number">0</span>])</span><br><span class="line">            )</span><br><span class="line">            previous_length = length</span><br></pre></td></tr></table></figure>



<h4 id="总结数据变异流程"><a href="#总结数据变异流程" class="headerlink" title="总结数据变异流程"></a>总结数据变异流程</h4><p>一次<code>fuzz_case</code>所用的变异数据来自于<code>mutation_context</code>，<code>mutation_context</code>由<code>message_path</code>和mutations组成。</p>
<p>mutations产生于primitive，对primitive的一次变异产生一个mutation，mutation中包含变异值和所属的primitive的<code>qualified_name</code>。</p>
<p>根据传入的depth的数值，<code>mutation_context</code>可以包含多个mutation，只不过默认值depth为1，因此<code>mutation_context</code>一般就包含一个mutation。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#session._main_fuzz_loop()</span></span><br><span class="line"><span class="keyword">for</span> mutation_context <span class="keyword">in</span> fuzz_case_iterator:</span><br><span class="line">    <span class="keyword">if</span> self.total_mutant_index &lt; self._index_start:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#session._generate_n_mutations_for_path()</span></span><br><span class="line">self.total_mutant_index += <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> MutationContext(message_path=path, mutations=&#123;n.qualified_name: n <span class="keyword">for</span> n <span class="keyword">in</span> mutations&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fuzzable.get_mutations()</span></span><br><span class="line"><span class="keyword">yield</span> [Mutation(value=value, qualified_name=self.qualified_name, index=index)]</span><br></pre></td></tr></table></figure>

<p>变量<code>total_mutant_index</code>标记产生了多少<code>mutation_context</code>，也就等同于<code>fuzz_case</code>的次数。</p>
<p>变量<code>mutant_index</code>标记产生了多少mutant(mutation),在depth为1的情况下，<code>mutant_index</code>就等于<code>total_mutant_index</code>。</p>
<p>而mutation的产生则是首先会遍历出状态图的所有path，然后对path中最后一个node中的item进行变异。</p>
<h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>这里再分析下刚才没提到的一些细节，其实整体框架和流程已经分析完了，但是对这些小细节也比较清楚的话，能更好的了解boofuzz。</p>
<h4 id="qualified-name"><a href="#qualified-name" class="headerlink" title="qualified_name"></a>qualified_name</h4><p>我们创建primitive时一般只给个<code>default_value</code>，这样在Fuzzable里，就会默认赋值个name，格式是类型加计数，例如String1,String2。</p>
<p>primitive的<code>context_path</code>是在push的时候赋予的，标记着的是其在request中的位置。</p>
<p>最后<code>qualified_name</code>的产生是将<code>context_path</code>和name拼接在一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Fuzzable._init()</span></span><br><span class="line"><span class="keyword">if</span> self._name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    Fuzzable.name_counter += <span class="number">1</span></span><br><span class="line">    self._name = <span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(self).__name__, Fuzzable.name_counter)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#Request.push()</span></span><br><span class="line">item.context_path = self._generate_context_path(self.block_stack)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_context_path</span>(<span class="params">self, block_stack</span>):</span></span><br><span class="line">    context_path = <span class="string">&quot;.&quot;</span>.join(x.name <span class="keyword">for</span> x <span class="keyword">in</span> block_stack)  <span class="comment"># TODO put in method</span></span><br><span class="line">    context_path = <span class="string">&quot;.&quot;</span>.join(<span class="built_in">filter</span>(<span class="literal">None</span>, (self.name, context_path)))</span><br><span class="line">    <span class="keyword">return</span> context_path</span><br><span class="line"><span class="comment">#Fuzzable.qualified_name</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qualified_name</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Dot-delimited name that describes the request name and the path to the element within the request.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Example: &quot;request1.block1.block2.node1&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>.join(s <span class="keyword">for</span> s <span class="keyword">in</span> (self._context_path, self.name) <span class="keyword">if</span> s != <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="path数据发送"><a href="#path数据发送" class="headerlink" title="path数据发送"></a>path数据发送</h4><p>前面已经介绍了变异值数据产生和数据发送，但是实际上数据产生和数据发送间还有一些细节没分析。</p>
<p>为了贴合网络协议，boofuzz在发送变异数据前，会先把其path上的正常数据先都发送过去，变异mutation都是在path的最后一个node上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#seesion._fuzz_current_case()</span></span><br><span class="line"><span class="comment">#这里是正常发送message_path最后一条路径前面的路径数据，这里就可以看出boofuzz是按node Fuzz的</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> mutation_context.message_path[:-<span class="number">1</span>]:</span><br><span class="line">        prev_node = self.nodes[e.src]</span><br><span class="line">        node = self.nodes[e.dst]</span><br><span class="line">        protocol_session = ProtocolSession(</span><br><span class="line">            previous_message=prev_node,</span><br><span class="line">            current_message=node,</span><br><span class="line">        )</span><br><span class="line">        mutation_context.protocol_session = protocol_session</span><br><span class="line">        callback_data = self._callback_current_node(node=node, edge=e, test_case_context=protocol_session)</span><br><span class="line">        self._fuzz_data_logger.open_test_step(<span class="string">&quot;Transmit Prep Node &#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(node.name))</span><br><span class="line">        self.transmit_normal(target, node, e, callback_data=callback_data,mutation_context=mutation_context)</span><br></pre></td></tr></table></figure>



<h5 id="transmit-normal"><a href="#transmit-normal" class="headerlink" title="transmit_normal"></a>transmit_normal</h5><p>如果<code>callback_data</code>不为空就发送<code>callback_data</code>，否则发送<code>render(mutation_context)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transmit_normal</span>(<span class="params">self, sock, node, edge, callback_data, mutation_context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Render and transmit a non-fuzzed node, process callbacks accordingly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        sock (Target, optional): Socket-like object on which to transmit node</span></span><br><span class="line"><span class="string">        node (pgraph.node.node (Node), optional): Request/Node to transmit</span></span><br><span class="line"><span class="string">        edge (pgraph.edge.edge (pgraph.edge), optional): Edge along the current fuzz path from &quot;node&quot; to next node.</span></span><br><span class="line"><span class="string">        callback_data (bytes): Data from previous callback.</span></span><br><span class="line"><span class="string">        mutation_context (MutationContext): active mutation context</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> callback_data:</span><br><span class="line">        data = callback_data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = node.render(mutation_context=mutation_context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># send</span></span><br><span class="line">        self.targets[<span class="number">0</span>].send(data)</span><br><span class="line">        self.last_send = data</span><br><span class="line">    <span class="keyword">if</span> self._receive_data_after_each_request:</span><br><span class="line">        self.last_recv = self.targets[<span class="number">0</span>].recv()</span><br></pre></td></tr></table></figure>



<h5 id="request-render"><a href="#request-render" class="headerlink" title="request.render"></a>request.render</h5><p>这个函数流程前面也没分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render</span>(<span class="params">self, mutation_context=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.block_stack:</span><br><span class="line">        <span class="keyword">raise</span> exception.SullyRuntimeError(<span class="string">&quot;UNCLOSED BLOCK: %s&quot;</span> % self.block_stack[-<span class="number">1</span>].qualified_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.get_child_data(mutation_context=mutation_context)</span><br></pre></td></tr></table></figure>



<h5 id="request-get-child-data"><a href="#request-get-child-data" class="headerlink" title="request.get_child_data"></a>request.get_child_data</h5><p>这个函数遍历request中的item，来拼接出数据，item基本都继承自Fuzzable(除了Block)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_child_data</span>(<span class="params">self, mutation_context</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get child or referenced data for this node.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For blocks that reference other data from the message structure (e.g. size, checksum, blocks). See</span></span><br><span class="line"><span class="string">    FuzzableBlock for an example.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        mutation_context (MutationContext): Mutation context.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bytes: Child data.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rendered = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> self.stack:</span><br><span class="line">        rendered += item.render(mutation_context=mutation_context)</span><br><span class="line">    <span class="keyword">return</span> rendered</span><br></pre></td></tr></table></figure>



<h5 id="Fuzzable-render"><a href="#Fuzzable-render" class="headerlink" title="Fuzzable.render"></a>Fuzzable.render</h5><p>调用<code>get_value</code>获取值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render</span>(<span class="params">self, mutation_context=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Render after applying mutation, if applicable.</span></span><br><span class="line"><span class="string">    :type mutation_context: MutationContext</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.encode(value=self.get_value(mutation_context=mutation_context),mutation_context=mutation_context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">self, value, mutation_context</span>):</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>



<h5 id="Fuzzable-get-value"><a href="#Fuzzable-get-value" class="headerlink" title="Fuzzable.get_value"></a>Fuzzable.get_value</h5><p>就是如果当前item在<code>mutation_context</code>的<code>qualified_name</code>中，就返回变异值，否则就返回初始值<code>_default_value</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span>(<span class="params">self, mutation_context=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper method to get the currently applicable value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is either the default value, or the active mutation value as dictated by mutation_context.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        mutation_context (MutationContext):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> mutation_context <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        mutation_context = MutationContext()</span><br><span class="line">    <span class="keyword">if</span> self.qualified_name <span class="keyword">in</span> mutation_context.mutations:</span><br><span class="line">        mutation = mutation_context.mutations[self.qualified_name]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">callable</span>(mutation.value):</span><br><span class="line">            value = mutation.value(self.original_value(test_case_context=mutation_context.protocol_session))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = mutation.value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = self.original_value(test_case_context=mutation_context.protocol_session)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>



<h5 id="original-value"><a href="#original-value" class="headerlink" title="original_value"></a>original_value</h5><p>因为传进来的都是ProtocolSession对象，所以走else分支返回<code>_default_value</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">original_value</span>(<span class="params">self, test_case_context=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Original, non-mutated value of element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        test_case_context (ProtocolSession): Used to resolve ReferenceValueTestCaseSession type default values.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#这个分支不知道什么时候用到</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._default_value, ProtocolSessionReference):</span><br><span class="line">        <span class="keyword">if</span> test_case_context <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self._default_value.default_value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> test_case_context.session_variables[self._default_value.name]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self._default_value</span><br></pre></td></tr></table></figure>

<p>继续上面数据发送的位置，path上的正常数据发送完之后才会发送变异数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prev_node = self.nodes[mutation_context.message_path[-<span class="number">1</span>].src]</span><br><span class="line">node = self.nodes[mutation_context.message_path[-<span class="number">1</span>].dst]</span><br><span class="line">protocol_session = ProtocolSession(</span><br><span class="line">    previous_message=prev_node,</span><br><span class="line">    current_message=node,</span><br><span class="line">)</span><br><span class="line">mutation_context.protocol_session = protocol_session</span><br><span class="line"><span class="comment">#这里会调用callback，同时返回一个callback数据</span></span><br><span class="line">callback_data = self._callback_current_node(</span><br><span class="line">    node=self.fuzz_node, edge=mutation_context.message_path[-<span class="number">1</span>], test_case_context=protocol_session</span><br><span class="line">)</span><br><span class="line">self._fuzz_data_logger.open_test_step(<span class="string">&quot;Fuzzing Node &#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(self.fuzz_node.name))</span><br><span class="line"><span class="comment">#进行实际的变异数据发送</span></span><br><span class="line">self.transmit_fuzz(</span><br><span class="line">    target,</span><br><span class="line">    self.fuzz_node,</span><br><span class="line">    mutation_context.message_path[-<span class="number">1</span>],</span><br><span class="line">    callback_data=callback_data,</span><br><span class="line">    mutation_context=mutation_context,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>boofuzz只提供了三种monitor：</p>
<p>ProcessMonitor大概是和Procman进行rpc通讯来监控；</p>
<p>NetworkMonitor具体用法不太清楚，看doc里说用了wireshark；</p>
<p>CallbackMonitor是默认的Monitor，提供回调函数的功能。</p>
<p>我们一般需要一个监控连接状态的Monitor，如果连接失败则判定为发生了crash，保存crash样本，前面代码中有我实现的简陋的方案。</p>
<h4 id="CallbackMonitor"><a href="#CallbackMonitor" class="headerlink" title="CallbackMonitor"></a>CallbackMonitor</h4><p>这个Monitor是以Monitor的形式提供几种callback，在session的init函数中,是把传进来的callback赋值给<code>CallbackMonitor</code>，这个Monitor也是会默认。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pre_send_callbacks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    pre_send_methods = []</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    pre_send_methods = pre_send_callbacks</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> post_test_case_callbacks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    post_test_case_methods = []</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    post_test_case_methods = post_test_case_callbacks</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> post_start_target_callbacks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    post_start_target_methods = []</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    post_start_target_methods = post_start_target_callbacks</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> restart_callbacks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    restart_methods = []</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    restart_methods = restart_callbacks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self._callback_monitor = CallbackMonitor(</span><br><span class="line">    on_pre_send=pre_send_methods,</span><br><span class="line">    on_post_send=post_test_case_methods,</span><br><span class="line">    on_restart_target=restart_methods,</span><br><span class="line">    on_post_start_target=post_start_target_methods,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">apply_options</span>(<span class="params">monitor</span>):</span></span><br><span class="line">                monitor.set_options(crash_filename=self._crash_filename)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            target.monitor_alive.append(apply_options)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.add_target(target)</span><br><span class="line">            <span class="keyword">except</span> exception.BoofuzzRpcError <span class="keyword">as</span> e:</span><br><span class="line">                self._fuzz_data_logger.log_error(<span class="built_in">str</span>(e))</span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>

<p>前面回调函数都是用的target的monitor的回调，在session的init中首先设置了<code>_callback_monitor</code>为刚才创建的<code>CallbackMonitor</code>，其给target设置的有些隐蔽，是在<code>add_target</code>中设置的。</p>
<h5 id="add-target"><a href="#add-target" class="headerlink" title="add_target"></a>add_target</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_target</span>(<span class="params">self, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add a target to the session. Multiple targets can be added for parallel fuzzing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        target (Target): Target to add to session</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass specified target parameters to the PED-RPC server.</span></span><br><span class="line">    target.monitors_alive()</span><br><span class="line">    target.set_fuzz_data_logger(fuzz_data_logger=self._fuzz_data_logger)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._callback_monitor <span class="keyword">not</span> <span class="keyword">in</span> target.monitors:</span><br><span class="line">        target.monitors.append(self._callback_monitor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add target to internal list.</span></span><br><span class="line">    self.targets.append(target)</span><br></pre></td></tr></table></figure>



<h5 id="pre-send-1"><a href="#pre-send-1" class="headerlink" title="pre_send"></a>pre_send</h5><p>以<code>CallbackMonitor</code>的<code>pre_send</code>为例，可以看到其遍历<code>on_pre_send</code>函数来调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_send</span>(<span class="params">self, target=<span class="literal">None</span>, fuzz_data_logger=<span class="literal">None</span>, session=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This method iterates over all supplied pre send callbacks and executes them.</span></span><br><span class="line"><span class="string">    Their return values are discarded, exceptions are catched and logged, but otherwise</span></span><br><span class="line"><span class="string">    discarded.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> self.on_pre_send:</span><br><span class="line">            fuzz_data_logger.open_test_step(<span class="string">&#x27;Pre_Send callback: &quot;&#123;0&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(f.__name__))</span><br><span class="line">            f(target=target, fuzz_data_logger=fuzz_data_logger, session=session, sock=target)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        fuzz_data_logger.log_error(</span><br><span class="line">            constants.ERR_CALLBACK_FUNC.<span class="built_in">format</span>(func_name=<span class="string">&quot;pre_send&quot;</span>) + traceback.format_exc()</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>



<h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h3><p><a href="https://x1aor0.github.io/2022/01/14/BoofuzzDoc/">Boofuzz分析</a></p>
<p><a href="https://boofuzz.readthedocs.io/en/stable/index.html">boofuzz 0.4.0 documentation</a></p>
<p><a href="https://paper.seebug.org/1626/">IoT设备固件分析之网络协议 fuzz (seebug.org)</a></p>
]]></content>
      <categories>
        <category>Fuzzing</category>
      </categories>
      <tags>
        <tag>Fuzzer</tag>
      </tags>
  </entry>
</search>
